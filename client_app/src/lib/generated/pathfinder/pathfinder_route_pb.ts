// @generated by protoc-gen-es v2.10.2 with parameter "target=ts"
// @generated from file pathfinder_route.proto (package pathfinder.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_buf_validate_validate } from "./buf/validate/validate_pb";
import type { EmptySchema } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file pathfinder_route.proto.
 */
export const file_pathfinder_route: GenFile = /*@__PURE__*/
  fileDesc("ChZwYXRoZmluZGVyX3JvdXRlLnByb3RvEg1wYXRoZmluZGVyLnYxIrUCCg9GaW5kUGF0aFJlcXVlc3QSGgoKY2hhaW5fZnJvbRgBIAEoCUIGukgDyAEBEicKEHRva2VuX2Zyb21fZGVub20YAiABKAlCDbpICsgBAXIFEAEYgAESGQoJYW1vdW50X2luGAMgASgJQga6SAPIAQESGAoIY2hhaW5fdG8YBCABKAlCBrpIA8gBARIgCg50b2tlbl90b19kZW5vbRgFIAEoCUIIukgFcgMYgAESJAoOc2VuZGVyX2FkZHJlc3MYBiABKAlCDLpICcgBAXIEECYYRBImChByZWNlaXZlcl9hZGRyZXNzGAcgASgJQgy6SAnIAQFyBBAmGEQSEwoLc21hcnRfcm91dGUYCCABKAgSIwoMc2xpcHBhZ2VfYnBzGAkgASgNQg26SArIAQAqBRiQTigAItoBChBGaW5kUGF0aFJlc3BvbnNlEg8KB3N1Y2Nlc3MYASABKAgSFQoNZXJyb3JfbWVzc2FnZRgCIAEoCRIsCgZkaXJlY3QYAyABKAsyGi5wYXRoZmluZGVyLnYxLkRpcmVjdFJvdXRlSAASMAoIaW5kaXJlY3QYBCABKAsyHC5wYXRoZmluZGVyLnYxLkluZGlyZWN0Um91dGVIABI1Cgticm9rZXJfc3dhcBgFIAEoCzIeLnBhdGhmaW5kZXIudjEuQnJva2VyU3dhcFJvdXRlSABCBwoFcm91dGUiNgoLRGlyZWN0Um91dGUSJwoIdHJhbnNmZXIYASABKAsyFS5wYXRoZmluZGVyLnYxLklCQ0xlZyKDAQoNSW5kaXJlY3RSb3V0ZRIMCgRwYXRoGAEgAygJEiMKBGxlZ3MYAiADKAsyFS5wYXRoZmluZGVyLnYxLklCQ0xlZxIUCgxzdXBwb3J0c19wZm0YAyABKAgSFwoPcGZtX3N0YXJ0X2NoYWluGAQgASgJEhAKCHBmbV9tZW1vGAUgASgJIvgBCg9Ccm9rZXJTd2FwUm91dGUSDAoEcGF0aBgBIAMoCRIrCgxpbmJvdW5kX2xlZ3MYAiADKAsyFS5wYXRoZmluZGVyLnYxLklCQ0xlZxImCgRzd2FwGAMgASgLMhgucGF0aGZpbmRlci52MS5Td2FwUXVvdGUSLAoNb3V0Ym91bmRfbGVncxgEIAMoCzIVLnBhdGhmaW5kZXIudjEuSUJDTGVnEh0KFW91dGJvdW5kX3N1cHBvcnRzX3BmbRgFIAEoCBI1CglleGVjdXRpb24YBiABKAsyIi5wYXRoZmluZGVyLnYxLkJyb2tlckV4ZWN1dGlvbkRhdGEijAIKE0Jyb2tlckV4ZWN1dGlvbkRhdGESEQoEbWVtbxgBIAEoCUgAiAEBEjkKE3NtYXJ0X2NvbnRyYWN0X2RhdGEYAiABKAsyFy5wYXRoZmluZGVyLnYxLldhc21EYXRhSAGIAQESGQoMaWJjX3JlY2VpdmVyGAMgASgJSAKIAQESFwoPcmVjb3Zlcl9hZGRyZXNzGAQgASgJEhkKEW1pbl9vdXRwdXRfYW1vdW50GAUgASgJEhEKCXVzZXNfd2FzbRgGIAEoCBITCgtkZXNjcmlwdGlvbhgHIAEoCUIHCgVfbWVtb0IWChRfc21hcnRfY29udHJhY3RfZGF0YUIPCg1faWJjX3JlY2VpdmVyIokBCgZJQkNMZWcSEgoKZnJvbV9jaGFpbhgBIAEoCRIQCgh0b19jaGFpbhgCIAEoCRIPCgdjaGFubmVsGAMgASgJEgwKBHBvcnQYBCABKAkSKgoFdG9rZW4YBSABKAsyGy5wYXRoZmluZGVyLnYxLlRva2VuTWFwcGluZxIOCgZhbW91bnQYBiABKAkiYAoMVG9rZW5NYXBwaW5nEhMKC2NoYWluX2Rlbm9tGAEgASgJEhIKCmJhc2VfZGVub20YAiABKAkSFAoMb3JpZ2luX2NoYWluGAMgASgJEhEKCWlzX25hdGl2ZRgEIAEoCCKbAgoJU3dhcFF1b3RlEg4KBmJyb2tlchgBIAEoCRItCgh0b2tlbl9pbhgCIAEoCzIbLnBhdGhmaW5kZXIudjEuVG9rZW5NYXBwaW5nEi4KCXRva2VuX291dBgDIAEoCzIbLnBhdGhmaW5kZXIudjEuVG9rZW5NYXBwaW5nEhEKCWFtb3VudF9pbhgEIAEoCRISCgphbW91bnRfb3V0GAUgASgJEhQKDHByaWNlX2ltcGFjdBgGIAEoCRIVCg1lZmZlY3RpdmVfZmVlGAcgASgJEj0KEm9zbW9zaXNfcm91dGVfZGF0YRgIIAEoCzIfLnBhdGhmaW5kZXIudjEuT3Ntb3Npc1JvdXRlRGF0YUgAQgwKCnJvdXRlX2RhdGEidgoQT3Ntb3Npc1JvdXRlRGF0YRIrCgZyb3V0ZXMYASADKAsyGy5wYXRoZmluZGVyLnYxLk9zbW9zaXNSb3V0ZRIVCg1saXF1aWRpdHlfY2FwGAIgASgJEh4KFmxpcXVpZGl0eV9jYXBfb3ZlcmZsb3cYAyABKAgidQoMT3Ntb3Npc1JvdXRlEikKBXBvb2xzGAEgAygLMhoucGF0aGZpbmRlci52MS5Pc21vc2lzUG9vbBITCgtoYXNfY3dfcG9vbBgCIAEoCBISCgpvdXRfYW1vdW50GAMgASgJEhEKCWluX2Ftb3VudBgEIAEoCSKBAQoLT3Ntb3Npc1Bvb2wSCgoCaWQYASABKAUSDAoEdHlwZRgCIAEoBRIVCg1zcHJlYWRfZmFjdG9yGAMgASgJEhcKD3Rva2VuX291dF9kZW5vbRgEIAEoCRIRCgl0YWtlcl9mZWUYBSABKAkSFQoNbGlxdWlkaXR5X2NhcBgGIAEoCSJMChJMb29rdXBEZW5vbVJlcXVlc3QSGAoIY2hhaW5faWQYASABKAlCBrpIA8gBARIcCgVkZW5vbRgCIAEoCUINukgKyAEBcgUQARiAASK5AQoTTG9va3VwRGVub21SZXNwb25zZRINCgVmb3VuZBgBIAEoCBITCgtjaGFpbl9kZW5vbRgCIAEoCRISCgpiYXNlX2Rlbm9tGAMgASgJEhQKDG9yaWdpbl9jaGFpbhgEIAEoCRIRCglpc19uYXRpdmUYBSABKAgSEAoIaWJjX3BhdGgYBiABKAkSLwoMYXZhaWxhYmxlX29uGAcgAygLMhkucGF0aGZpbmRlci52MS5DaGFpbkRlbm9tIlQKCkNoYWluRGVub20SEAoIY2hhaW5faWQYASABKAkSEgoKY2hhaW5fbmFtZRgCIAEoCRINCgVkZW5vbRgDIAEoCRIRCglpc19uYXRpdmUYBCABKAgiZgoVR2V0VG9rZW5EZW5vbXNSZXF1ZXN0EhoKCmJhc2VfZGVub20YASABKAlCBrpIA8gBARIcCgxvcmlnaW5fY2hhaW4YAiABKAlCBrpIA8gBARITCgtvbl9jaGFpbl9pZBgDIAEoCSJ8ChZHZXRUb2tlbkRlbm9tc1Jlc3BvbnNlEg0KBWZvdW5kGAEgASgIEhIKCmJhc2VfZGVub20YAiABKAkSFAoMb3JpZ2luX2NoYWluGAMgASgJEikKBmRlbm9tcxgEIAMoCzIZLnBhdGhmaW5kZXIudjEuQ2hhaW5EZW5vbSIxChVHZXRDaGFpblRva2Vuc1JlcXVlc3QSGAoIY2hhaW5faWQYASABKAlCBrpIA8gBASKjAQoWR2V0Q2hhaW5Ub2tlbnNSZXNwb25zZRIQCghjaGFpbl9pZBgBIAEoCRISCgpjaGFpbl9uYW1lGAIgASgJEjIKDW5hdGl2ZV90b2tlbnMYAyADKAsyGy5wYXRoZmluZGVyLnYxLlRva2VuRGV0YWlscxIvCgppYmNfdG9rZW5zGAQgAygLMhsucGF0aGZpbmRlci52MS5Ub2tlbkRldGFpbHMifAoMVG9rZW5EZXRhaWxzEg0KBWRlbm9tGAEgASgJEg4KBnN5bWJvbBgCIAEoCRISCgpiYXNlX2Rlbm9tGAMgASgJEhQKDG9yaWdpbl9jaGFpbhgEIAEoCRIQCghkZWNpbWFscxgFIAEoBRIRCglpc19uYXRpdmUYBiABKAgiPgohUGF0aGZpbmRlclN1cHBvcnRlZENoYWluc1Jlc3BvbnNlEhkKCWNoYWluX2lkcxgBIAMoCUIGukgDyAEBIkIKEENoYWluSW5mb1JlcXVlc3QSGAoIY2hhaW5faWQYASABKAlCBrpIA8gBARIUCgxzaG93X3N5bWJvbHMYAiABKAgiQQoRQ2hhaW5JbmZvUmVzcG9uc2USLAoKY2hhaW5faW5mbxgBIAEoCzIYLnBhdGhmaW5kZXIudjEuQ2hhaW5JbmZvIoABCglDaGFpbkluZm8SEAoIY2hhaW5faWQYASABKAkSEgoKY2hhaW5fbmFtZRgCIAEoCRIPCgdoYXNfcGZtGAMgASgIEhEKCWlzX2Jyb2tlchgEIAEoCBIpCgZyb3V0ZXMYBSADKAsyGS5wYXRoZmluZGVyLnYxLkJhc2ljUm91dGUifwoJVG9rZW5JbmZvEhMKC2NoYWluX2Rlbm9tGAEgASgJEhEKCWliY19kZW5vbRgCIAEoCRISCgpiYXNlX2Rlbm9tGAMgASgJEhQKDG9yaWdpbl9jaGFpbhgEIAEoCRIQCghkZWNpbWFscxgFIAEoBRIOCgZzeW1ib2wYBiABKAkihQIKCkJhc2ljUm91dGUSEAoIdG9fY2hhaW4YASABKAkSEwoLdG9fY2hhaW5faWQYAiABKAkSFQoNY29ubmVjdGlvbl9pZBgDIAEoCRISCgpjaGFubmVsX2lkGAQgASgJEg8KB3BvcnRfaWQYBSABKAkSRAoOYWxsb3dlZF90b2tlbnMYBiADKAsyLC5wYXRoZmluZGVyLnYxLkJhc2ljUm91dGUuQWxsb3dlZFRva2Vuc0VudHJ5Gk4KEkFsbG93ZWRUb2tlbnNFbnRyeRILCgNrZXkYASABKAkSJwoFdmFsdWUYAiABKAsyGC5wYXRoZmluZGVyLnYxLlRva2VuSW5mbzoCOAEiQQoIV2FzbURhdGESEAoIY29udHJhY3QYASABKAkSIwoDbXNnGAIgASgLMhYucGF0aGZpbmRlci52MS5XYXNtTXNnIkAKB1dhc21Nc2cSNQoPc3dhcF9hbmRfYWN0aW9uGAEgASgLMhwucGF0aGZpbmRlci52MS5Td2FwQW5kQWN0aW9uIs8BCg1Td2FwQW5kQWN0aW9uEioKCXVzZXJfc3dhcBgBIAEoCzIXLnBhdGhmaW5kZXIudjEuVXNlclN3YXASKgoJbWluX2Fzc2V0GAIgASgLMhcucGF0aGZpbmRlci52MS5NaW5Bc3NldBIZChF0aW1lb3V0X3RpbWVzdGFtcBgDIAEoAxI3ChBwb3N0X3N3YXBfYWN0aW9uGAQgASgLMh0ucGF0aGZpbmRlci52MS5Qb3N0U3dhcEFjdGlvbhISCgphZmZpbGlhdGVzGAUgAygJIl0KEFN3YXBFeGFjdEFzc2V0SW4SFwoPc3dhcF92ZW51ZV9uYW1lGAEgASgJEjAKCm9wZXJhdGlvbnMYAiADKAsyHC5wYXRoZmluZGVyLnYxLlN3YXBPcGVyYXRpb24iaAoNU3dhcE9wZXJhdGlvbhIMCgRwb29sGAEgASgJEhAKCGRlbm9tX2luGAIgASgJEhEKCWRlbm9tX291dBgDIAEoCRIWCglpbnRlcmZhY2UYBCABKAlIAIgBAUIMCgpfaW50ZXJmYWNlIjAKCE1pbkFzc2V0EiQKBm5hdGl2ZRgBIAEoCzIULnBhdGhmaW5kZXIudjEuQXNzZXQiJgoFQXNzZXQSDgoGYW1vdW50GAEgASgJEg0KBWRlbm9tGAIgASgJInsKDlBvc3RTd2FwQWN0aW9uEjIKDGliY190cmFuc2ZlchgBIAEoCzIaLnBhdGhmaW5kZXIudjEuSUJDVHJhbnNmZXJIABIrCgh0cmFuc2ZlchgCIAEoCzIXLnBhdGhmaW5kZXIudjEuVHJhbnNmZXJIAEIICgZhY3Rpb24iNwoLSUJDVHJhbnNmZXISKAoIaWJjX2luZm8YASABKAsyFi5wYXRoZmluZGVyLnYxLklCQ0luZm8iHgoIVHJhbnNmZXISEgoKdG9fYWRkcmVzcxgBIAEoCSJaCgdJQkNJbmZvEgwKBG1lbW8YASABKAkSEAoIcmVjZWl2ZXIYAiABKAkSFwoPcmVjb3Zlcl9hZGRyZXNzGAMgASgJEhYKDnNvdXJjZV9jaGFubmVsGAQgASgJIkgKCFVzZXJTd2FwEjwKE3N3YXBfZXhhY3RfYXNzZXRfaW4YASABKAsyHy5wYXRoZmluZGVyLnYxLlN3YXBFeGFjdEFzc2V0SW4yxgQKEVBhdGhmaW5kZXJTZXJ2aWNlElAKCEZpbmRQYXRoEh4ucGF0aGZpbmRlci52MS5GaW5kUGF0aFJlcXVlc3QaHy5wYXRoZmluZGVyLnYxLkZpbmRQYXRoUmVzcG9uc2UiA5ACARJZCgtMb29rdXBEZW5vbRIhLnBhdGhmaW5kZXIudjEuTG9va3VwRGVub21SZXF1ZXN0GiIucGF0aGZpbmRlci52MS5Mb29rdXBEZW5vbVJlc3BvbnNlIgOQAgESYgoOR2V0VG9rZW5EZW5vbXMSJC5wYXRoZmluZGVyLnYxLkdldFRva2VuRGVub21zUmVxdWVzdBolLnBhdGhmaW5kZXIudjEuR2V0VG9rZW5EZW5vbXNSZXNwb25zZSIDkAIBElYKDEdldENoYWluSW5mbxIfLnBhdGhmaW5kZXIudjEuQ2hhaW5JbmZvUmVxdWVzdBogLnBhdGhmaW5kZXIudjEuQ2hhaW5JbmZvUmVzcG9uc2UiA5ACARJkChNMaXN0U3VwcG9ydGVkQ2hhaW5zEhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5GjAucGF0aGZpbmRlci52MS5QYXRoZmluZGVyU3VwcG9ydGVkQ2hhaW5zUmVzcG9uc2UiA5ACARJiCg5HZXRDaGFpblRva2VucxIkLnBhdGhmaW5kZXIudjEuR2V0Q2hhaW5Ub2tlbnNSZXF1ZXN0GiUucGF0aGZpbmRlci52MS5HZXRDaGFpblRva2Vuc1Jlc3BvbnNlIgOQAgFCQVo/Z2l0aHViLmNvbS9Db2d3aGVlbC1WYWxpZGF0b3Ivc3BlY3RyYS1pYmMtaHViL3BhdGhmaW5kZXIvcnBjL3YxYgZwcm90bzM", [file_buf_validate_validate, file_google_protobuf_empty]);

/**
 * FindPathRequest - Find a route between chains
 *
 * For token_from_denom and token_to_denom, you can use:
 * - Human-readable denom (e.g., "uatone", "uosmo", "ustars")
 * - Full IBC denom (e.g., "ibc/ABC123...")
 *
 * The pathfinder will automatically resolve human-readable denoms.
 * If token_to_denom is empty, the pathfinder assumes you want the same token
 * on the destination chain (useful for bridging without swapping).
 *
 * @generated from message pathfinder.v1.FindPathRequest
 */
export type FindPathRequest = Message<"pathfinder.v1.FindPathRequest"> & {
  /**
   * Source chain ID (e.g., "osmosis-1", "atomone-1")
   *
   * @generated from field: string chain_from = 1;
   */
  chainFrom: string;

  /**
   * Token denom on source chain - can be human-readable (e.g., "uatone") 
   * or IBC denom (e.g., "ibc/...")
   *
   * @generated from field: string token_from_denom = 2;
   */
  tokenFromDenom: string;

  /**
   * Amount to transfer/swap (in base units)
   *
   * @generated from field: string amount_in = 3;
   */
  amountIn: string;

  /**
   * Destination chain ID
   *
   * @generated from field: string chain_to = 4;
   */
  chainTo: string;

  /**
   * Token denom you want to receive on destination chain
   * Can be human-readable (e.g., "uosmo") or IBC denom
   * If empty, assumes same token as token_from (bridging without swap)
   *
   * @generated from field: string token_to_denom = 5;
   */
  tokenToDenom: string;

  /**
   * Sender address on source chain
   *
   * @generated from field: string sender_address = 6;
   */
  senderAddress: string;

  /**
   * Receiver address on destination chain
   *
   * @generated from field: string receiver_address = 7;
   */
  receiverAddress: string;

  /**
   * If true, return a smart route, if false, return a normal route
   *
   * @generated from field: bool smart_route = 8;
   */
  smartRoute: boolean;

  /**
   * Slippage in basis points (e.g., 100 = 1%, 1000 = 10%)
   * Must be less than 10000
   *
   * @generated from field: uint32 slippage_bps = 9;
   */
  slippageBps: number;
};

/**
 * Describes the message pathfinder.v1.FindPathRequest.
 * Use `create(FindPathRequestSchema)` to create a new message.
 */
export const FindPathRequestSchema: GenMessage<FindPathRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 0);

/**
 * @generated from message pathfinder.v1.FindPathResponse
 */
export type FindPathResponse = Message<"pathfinder.v1.FindPathResponse"> & {
  /**
   * @generated from field: bool success = 1;
   */
  success: boolean;

  /**
   * @generated from field: string error_message = 2;
   */
  errorMessage: string;

  /**
   * @generated from oneof pathfinder.v1.FindPathResponse.route
   */
  route: {
    /**
     * @generated from field: pathfinder.v1.DirectRoute direct = 3;
     */
    value: DirectRoute;
    case: "direct";
  } | {
    /**
     * @generated from field: pathfinder.v1.IndirectRoute indirect = 4;
     */
    value: IndirectRoute;
    case: "indirect";
  } | {
    /**
     * @generated from field: pathfinder.v1.BrokerSwapRoute broker_swap = 5;
     */
    value: BrokerSwapRoute;
    case: "brokerSwap";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message pathfinder.v1.FindPathResponse.
 * Use `create(FindPathResponseSchema)` to create a new message.
 */
export const FindPathResponseSchema: GenMessage<FindPathResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 1);

/**
 * @generated from message pathfinder.v1.DirectRoute
 */
export type DirectRoute = Message<"pathfinder.v1.DirectRoute"> & {
  /**
   * @generated from field: pathfinder.v1.IBCLeg transfer = 1;
   */
  transfer?: IBCLeg;
};

/**
 * Describes the message pathfinder.v1.DirectRoute.
 * Use `create(DirectRouteSchema)` to create a new message.
 */
export const DirectRouteSchema: GenMessage<DirectRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 2);

/**
 * @generated from message pathfinder.v1.IndirectRoute
 */
export type IndirectRoute = Message<"pathfinder.v1.IndirectRoute"> & {
  /**
   * @generated from field: repeated string path = 1;
   */
  path: string[];

  /**
   * @generated from field: repeated pathfinder.v1.IBCLeg legs = 2;
   */
  legs: IBCLeg[];

  /**
   * @generated from field: bool supports_pfm = 3;
   */
  supportsPfm: boolean;

  /**
   * @generated from field: string pfm_start_chain = 4;
   */
  pfmStartChain: string;

  /**
   * @generated from field: string pfm_memo = 5;
   */
  pfmMemo: string;
};

/**
 * Describes the message pathfinder.v1.IndirectRoute.
 * Use `create(IndirectRouteSchema)` to create a new message.
 */
export const IndirectRouteSchema: GenMessage<IndirectRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 3);

/**
 * BrokerSwapRoute represents a route involving a swap on a broker chain.
 * Supports various scenarios:
 * - Same-chain swap: inbound_leg absent, outbound_legs=[] (e.g., osmosis ATOM -> osmosis OSMO)
 * - Swap from broker: inbound_leg absent (e.g., osmosis USDC -> juno JUNO)
 * - Standard 3-chain: inbound_leg set, len(outbound_legs)=1
 * - Multi-hop outbound: inbound_leg set, len(outbound_legs)>1 (e.g., cosmos ATOM -> swap -> noble -> juno)
 *
 * @generated from message pathfinder.v1.BrokerSwapRoute
 */
export type BrokerSwapRoute = Message<"pathfinder.v1.BrokerSwapRoute"> & {
  /**
   * All chain IDs in order
   *
   * @generated from field: repeated string path = 1;
   */
  path: string[];

  /**
   * IBC transfer to reach broker (absent if starting from broker)
   *
   * @generated from field: repeated pathfinder.v1.IBCLeg inbound_legs = 2;
   */
  inboundLegs: IBCLeg[];

  /**
   * The swap operation on the broker chain
   *
   * @generated from field: pathfinder.v1.SwapQuote swap = 3;
   */
  swap?: SwapQuote;

  /**
   * IBC transfers after swap (empty if destination is broker)
   * Can be multiple for multi-hop forwarding via PFM
   *
   * @generated from field: repeated pathfinder.v1.IBCLeg outbound_legs = 4;
   */
  outboundLegs: IBCLeg[];

  /**
   * Can use PFM for outbound legs
   *
   * @generated from field: bool outbound_supports_pfm = 5;
   */
  outboundSupportsPfm: boolean;

  /**
   * Execution data for building transactions
   *
   * @generated from field: pathfinder.v1.BrokerExecutionData execution = 6;
   */
  execution?: BrokerExecutionData;
};

/**
 * Describes the message pathfinder.v1.BrokerSwapRoute.
 * Use `create(BrokerSwapRouteSchema)` to create a new message.
 */
export const BrokerSwapRouteSchema: GenMessage<BrokerSwapRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 4);

/**
 * BrokerExecutionData contains ready-to-use transaction data
 *
 * @generated from message pathfinder.v1.BrokerExecutionData
 */
export type BrokerExecutionData = Message<"pathfinder.v1.BrokerExecutionData"> & {
  /**
   * The IBC memo to use with MsgTransfer (contains wasm swap_and_action)
   *
   * @generated from field: optional string memo = 1;
   */
  memo?: string;

  /**
   * The smart contract data to use with the swap and transfer
   *
   * @generated from field: optional pathfinder.v1.WasmData smart_contract_data = 2;
   */
  smartContractData?: WasmData;

  /**
   * Receiver address for MsgTransfer (the ibc-hooks contract)
   *
   * @generated from field: optional string ibc_receiver = 3;
   */
  ibcReceiver?: string;

  /**
   * Recovery address on broker chain (where funds go if swap/forward fails)
   *
   * @generated from field: string recover_address = 4;
   */
  recoverAddress: string;

  /**
   * Minimum output amount after slippage (1% default)
   *
   * @generated from field: string min_output_amount = 5;
   */
  minOutputAmount: string;

  /**
   * True if using wasm ibc-hooks (vs simple PFM)
   *
   * @generated from field: bool uses_wasm = 6;
   */
  usesWasm: boolean;

  /**
   * Human-readable description
   *
   * @generated from field: string description = 7;
   */
  description: string;
};

/**
 * Describes the message pathfinder.v1.BrokerExecutionData.
 * Use `create(BrokerExecutionDataSchema)` to create a new message.
 */
export const BrokerExecutionDataSchema: GenMessage<BrokerExecutionData> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 5);

/**
 * @generated from message pathfinder.v1.IBCLeg
 */
export type IBCLeg = Message<"pathfinder.v1.IBCLeg"> & {
  /**
   * @generated from field: string from_chain = 1;
   */
  fromChain: string;

  /**
   * @generated from field: string to_chain = 2;
   */
  toChain: string;

  /**
   * @generated from field: string channel = 3;
   */
  channel: string;

  /**
   * @generated from field: string port = 4;
   */
  port: string;

  /**
   * @generated from field: pathfinder.v1.TokenMapping token = 5;
   */
  token?: TokenMapping;

  /**
   * @generated from field: string amount = 6;
   */
  amount: string;
};

/**
 * Describes the message pathfinder.v1.IBCLeg.
 * Use `create(IBCLegSchema)` to create a new message.
 */
export const IBCLegSchema: GenMessage<IBCLeg> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 6);

/**
 * @generated from message pathfinder.v1.TokenMapping
 */
export type TokenMapping = Message<"pathfinder.v1.TokenMapping"> & {
  /**
   * The denom as it appears on the current chain (native or IBC)
   *
   * @generated from field: string chain_denom = 1;
   */
  chainDenom: string;

  /**
   * The base/native denom on the token's origin chain
   *
   * @generated from field: string base_denom = 2;
   */
  baseDenom: string;

  /**
   * The chain ID where this token is native
   *
   * @generated from field: string origin_chain = 3;
   */
  originChain: string;

  /**
   * True if this is the token's native chain
   *
   * @generated from field: bool is_native = 4;
   */
  isNative: boolean;
};

/**
 * Describes the message pathfinder.v1.TokenMapping.
 * Use `create(TokenMappingSchema)` to create a new message.
 */
export const TokenMappingSchema: GenMessage<TokenMapping> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 7);

/**
 * SwapQuote with broker-specific route data
 *
 * @generated from message pathfinder.v1.SwapQuote
 */
export type SwapQuote = Message<"pathfinder.v1.SwapQuote"> & {
  /**
   * @generated from field: string broker = 1;
   */
  broker: string;

  /**
   * @generated from field: pathfinder.v1.TokenMapping token_in = 2;
   */
  tokenIn?: TokenMapping;

  /**
   * @generated from field: pathfinder.v1.TokenMapping token_out = 3;
   */
  tokenOut?: TokenMapping;

  /**
   * @generated from field: string amount_in = 4;
   */
  amountIn: string;

  /**
   * @generated from field: string amount_out = 5;
   */
  amountOut: string;

  /**
   * @generated from field: string price_impact = 6;
   */
  priceImpact: string;

  /**
   * @generated from field: string effective_fee = 7;
   */
  effectiveFee: string;

  /**
   * Broker-specific route data using oneof for type safety
   *
   * @generated from oneof pathfinder.v1.SwapQuote.route_data
   */
  routeData: {
    /**
     * Future brokers can be added here without breaking existing clients
     *
     * @generated from field: pathfinder.v1.OsmosisRouteData osmosis_route_data = 8;
     */
    value: OsmosisRouteData;
    case: "osmosisRouteData";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message pathfinder.v1.SwapQuote.
 * Use `create(SwapQuoteSchema)` to create a new message.
 */
export const SwapQuoteSchema: GenMessage<SwapQuote> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 8);

/**
 * Osmosis-specific route data (from SQS API)
 *
 * @generated from message pathfinder.v1.OsmosisRouteData
 */
export type OsmosisRouteData = Message<"pathfinder.v1.OsmosisRouteData"> & {
  /**
   * @generated from field: repeated pathfinder.v1.OsmosisRoute routes = 1;
   */
  routes: OsmosisRoute[];

  /**
   * @generated from field: string liquidity_cap = 2;
   */
  liquidityCap: string;

  /**
   * @generated from field: bool liquidity_cap_overflow = 3;
   */
  liquidityCapOverflow: boolean;
};

/**
 * Describes the message pathfinder.v1.OsmosisRouteData.
 * Use `create(OsmosisRouteDataSchema)` to create a new message.
 */
export const OsmosisRouteDataSchema: GenMessage<OsmosisRouteData> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 9);

/**
 * @generated from message pathfinder.v1.OsmosisRoute
 */
export type OsmosisRoute = Message<"pathfinder.v1.OsmosisRoute"> & {
  /**
   * @generated from field: repeated pathfinder.v1.OsmosisPool pools = 1;
   */
  pools: OsmosisPool[];

  /**
   * @generated from field: bool has_cw_pool = 2;
   */
  hasCwPool: boolean;

  /**
   * @generated from field: string out_amount = 3;
   */
  outAmount: string;

  /**
   * @generated from field: string in_amount = 4;
   */
  inAmount: string;
};

/**
 * Describes the message pathfinder.v1.OsmosisRoute.
 * Use `create(OsmosisRouteSchema)` to create a new message.
 */
export const OsmosisRouteSchema: GenMessage<OsmosisRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 10);

/**
 * @generated from message pathfinder.v1.OsmosisPool
 */
export type OsmosisPool = Message<"pathfinder.v1.OsmosisPool"> & {
  /**
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * @generated from field: int32 type = 2;
   */
  type: number;

  /**
   * @generated from field: string spread_factor = 3;
   */
  spreadFactor: string;

  /**
   * @generated from field: string token_out_denom = 4;
   */
  tokenOutDenom: string;

  /**
   * @generated from field: string taker_fee = 5;
   */
  takerFee: string;

  /**
   * @generated from field: string liquidity_cap = 6;
   */
  liquidityCap: string;
};

/**
 * Describes the message pathfinder.v1.OsmosisPool.
 * Use `create(OsmosisPoolSchema)` to create a new message.
 */
export const OsmosisPoolSchema: GenMessage<OsmosisPool> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 11);

/**
 * LookupDenomRequest - Resolve token information
 * Accepts either:
 * - Human-readable denom (e.g., "uatone", "uosmo")
 * - IBC denom (e.g., "ibc/ABC123...")
 *
 * @generated from message pathfinder.v1.LookupDenomRequest
 */
export type LookupDenomRequest = Message<"pathfinder.v1.LookupDenomRequest"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: string denom = 2;
   */
  denom: string;
};

/**
 * Describes the message pathfinder.v1.LookupDenomRequest.
 * Use `create(LookupDenomRequestSchema)` to create a new message.
 */
export const LookupDenomRequestSchema: GenMessage<LookupDenomRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 12);

/**
 * @generated from message pathfinder.v1.LookupDenomResponse
 */
export type LookupDenomResponse = Message<"pathfinder.v1.LookupDenomResponse"> & {
  /**
   * @generated from field: bool found = 1;
   */
  found: boolean;

  /**
   * The denom as it appears on this chain
   *
   * @generated from field: string chain_denom = 2;
   */
  chainDenom: string;

  /**
   * The base/native denom
   *
   * @generated from field: string base_denom = 3;
   */
  baseDenom: string;

  /**
   * Where this token is native
   *
   * @generated from field: string origin_chain = 4;
   */
  originChain: string;

  /**
   * True if this is the token's native chain
   *
   * @generated from field: bool is_native = 5;
   */
  isNative: boolean;

  /**
   * IBC path if this is an IBC token (e.g., "transfer/channel-75")
   *
   * @generated from field: string ibc_path = 6;
   */
  ibcPath: string;

  /**
   * Denoms on other chains where this token is available
   *
   * @generated from field: repeated pathfinder.v1.ChainDenom available_on = 7;
   */
  availableOn: ChainDenom[];
};

/**
 * Describes the message pathfinder.v1.LookupDenomResponse.
 * Use `create(LookupDenomResponseSchema)` to create a new message.
 */
export const LookupDenomResponseSchema: GenMessage<LookupDenomResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 13);

/**
 * ChainDenom represents a token's denom on a specific chain
 *
 * @generated from message pathfinder.v1.ChainDenom
 */
export type ChainDenom = Message<"pathfinder.v1.ChainDenom"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: string chain_name = 2;
   */
  chainName: string;

  /**
   * @generated from field: string denom = 3;
   */
  denom: string;

  /**
   * @generated from field: bool is_native = 4;
   */
  isNative: boolean;
};

/**
 * Describes the message pathfinder.v1.ChainDenom.
 * Use `create(ChainDenomSchema)` to create a new message.
 */
export const ChainDenomSchema: GenMessage<ChainDenom> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 14);

/**
 * GetTokenDenomsRequest - Get all denoms for a token across chains
 * Use this to discover what denom a token has on different chains
 *
 * @generated from message pathfinder.v1.GetTokenDenomsRequest
 */
export type GetTokenDenomsRequest = Message<"pathfinder.v1.GetTokenDenomsRequest"> & {
  /**
   * The base denom (e.g., "uatone", "uosmo", "ustars")
   *
   * @generated from field: string base_denom = 1;
   */
  baseDenom: string;

  /**
   * The chain where this token is native (e.g., "atomone-1", "osmosis-1")
   *
   * @generated from field: string origin_chain = 2;
   */
  originChain: string;

  /**
   * Optional: Filter to a specific chain. If empty, returns denoms on all chains
   *
   * @generated from field: string on_chain_id = 3;
   */
  onChainId: string;
};

/**
 * Describes the message pathfinder.v1.GetTokenDenomsRequest.
 * Use `create(GetTokenDenomsRequestSchema)` to create a new message.
 */
export const GetTokenDenomsRequestSchema: GenMessage<GetTokenDenomsRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 15);

/**
 * @generated from message pathfinder.v1.GetTokenDenomsResponse
 */
export type GetTokenDenomsResponse = Message<"pathfinder.v1.GetTokenDenomsResponse"> & {
  /**
   * @generated from field: bool found = 1;
   */
  found: boolean;

  /**
   * @generated from field: string base_denom = 2;
   */
  baseDenom: string;

  /**
   * @generated from field: string origin_chain = 3;
   */
  originChain: string;

  /**
   * All chains where this token is available and what denom it has
   *
   * @generated from field: repeated pathfinder.v1.ChainDenom denoms = 4;
   */
  denoms: ChainDenom[];
};

/**
 * Describes the message pathfinder.v1.GetTokenDenomsResponse.
 * Use `create(GetTokenDenomsResponseSchema)` to create a new message.
 */
export const GetTokenDenomsResponseSchema: GenMessage<GetTokenDenomsResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 16);

/**
 * GetChainTokensRequest - Get all tokens on a chain
 *
 * @generated from message pathfinder.v1.GetChainTokensRequest
 */
export type GetChainTokensRequest = Message<"pathfinder.v1.GetChainTokensRequest"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;
};

/**
 * Describes the message pathfinder.v1.GetChainTokensRequest.
 * Use `create(GetChainTokensRequestSchema)` to create a new message.
 */
export const GetChainTokensRequestSchema: GenMessage<GetChainTokensRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 17);

/**
 * @generated from message pathfinder.v1.GetChainTokensResponse
 */
export type GetChainTokensResponse = Message<"pathfinder.v1.GetChainTokensResponse"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: string chain_name = 2;
   */
  chainName: string;

  /**
   * Native tokens on this chain
   *
   * @generated from field: repeated pathfinder.v1.TokenDetails native_tokens = 3;
   */
  nativeTokens: TokenDetails[];

  /**
   * IBC tokens received on this chain
   *
   * @generated from field: repeated pathfinder.v1.TokenDetails ibc_tokens = 4;
   */
  ibcTokens: TokenDetails[];
};

/**
 * Describes the message pathfinder.v1.GetChainTokensResponse.
 * Use `create(GetChainTokensResponseSchema)` to create a new message.
 */
export const GetChainTokensResponseSchema: GenMessage<GetChainTokensResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 18);

/**
 * TokenDetails - Full token information
 *
 * @generated from message pathfinder.v1.TokenDetails
 */
export type TokenDetails = Message<"pathfinder.v1.TokenDetails"> & {
  /**
   * Denom on this chain (native or IBC hash)
   *
   * @generated from field: string denom = 1;
   */
  denom: string;

  /**
   * Human-readable symbol (e.g., "ATONE", "OSMO")
   *
   * @generated from field: string symbol = 2;
   */
  symbol: string;

  /**
   * Base denom on origin chain
   *
   * @generated from field: string base_denom = 3;
   */
  baseDenom: string;

  /**
   * Chain where token is native
   *
   * @generated from field: string origin_chain = 4;
   */
  originChain: string;

  /**
   * Number of decimals
   *
   * @generated from field: int32 decimals = 5;
   */
  decimals: number;

  /**
   * True if native to this chain
   *
   * @generated from field: bool is_native = 6;
   */
  isNative: boolean;
};

/**
 * Describes the message pathfinder.v1.TokenDetails.
 * Use `create(TokenDetailsSchema)` to create a new message.
 */
export const TokenDetailsSchema: GenMessage<TokenDetails> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 19);

/**
 * @generated from message pathfinder.v1.PathfinderSupportedChainsResponse
 */
export type PathfinderSupportedChainsResponse = Message<"pathfinder.v1.PathfinderSupportedChainsResponse"> & {
  /**
   * @generated from field: repeated string chain_ids = 1;
   */
  chainIds: string[];
};

/**
 * Describes the message pathfinder.v1.PathfinderSupportedChainsResponse.
 * Use `create(PathfinderSupportedChainsResponseSchema)` to create a new message.
 */
export const PathfinderSupportedChainsResponseSchema: GenMessage<PathfinderSupportedChainsResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 20);

/**
 * @generated from message pathfinder.v1.ChainInfoRequest
 */
export type ChainInfoRequest = Message<"pathfinder.v1.ChainInfoRequest"> & {
  /**
   * The chain id of the chain to get information for
   *
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * Whether to show the symbols of the tokens on the chain, default is false
   *
   * @generated from field: bool show_symbols = 2;
   */
  showSymbols: boolean;
};

/**
 * Describes the message pathfinder.v1.ChainInfoRequest.
 * Use `create(ChainInfoRequestSchema)` to create a new message.
 */
export const ChainInfoRequestSchema: GenMessage<ChainInfoRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 21);

/**
 * @generated from message pathfinder.v1.ChainInfoResponse
 */
export type ChainInfoResponse = Message<"pathfinder.v1.ChainInfoResponse"> & {
  /**
   * @generated from field: pathfinder.v1.ChainInfo chain_info = 1;
   */
  chainInfo?: ChainInfo;
};

/**
 * Describes the message pathfinder.v1.ChainInfoResponse.
 * Use `create(ChainInfoResponseSchema)` to create a new message.
 */
export const ChainInfoResponseSchema: GenMessage<ChainInfoResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 22);

/**
 * @generated from message pathfinder.v1.ChainInfo
 */
export type ChainInfo = Message<"pathfinder.v1.ChainInfo"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: string chain_name = 2;
   */
  chainName: string;

  /**
   * @generated from field: bool has_pfm = 3;
   */
  hasPfm: boolean;

  /**
   * @generated from field: bool is_broker = 4;
   */
  isBroker: boolean;

  /**
   * @generated from field: repeated pathfinder.v1.BasicRoute routes = 5;
   */
  routes: BasicRoute[];
};

/**
 * Describes the message pathfinder.v1.ChainInfo.
 * Use `create(ChainInfoSchema)` to create a new message.
 */
export const ChainInfoSchema: GenMessage<ChainInfo> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 23);

/**
 * @generated from message pathfinder.v1.TokenInfo
 */
export type TokenInfo = Message<"pathfinder.v1.TokenInfo"> & {
  /**
   * @generated from field: string chain_denom = 1;
   */
  chainDenom: string;

  /**
   * @generated from field: string ibc_denom = 2;
   */
  ibcDenom: string;

  /**
   * @generated from field: string base_denom = 3;
   */
  baseDenom: string;

  /**
   * @generated from field: string origin_chain = 4;
   */
  originChain: string;

  /**
   * @generated from field: int32 decimals = 5;
   */
  decimals: number;

  /**
   * @generated from field: string symbol = 6;
   */
  symbol: string;
};

/**
 * Describes the message pathfinder.v1.TokenInfo.
 * Use `create(TokenInfoSchema)` to create a new message.
 */
export const TokenInfoSchema: GenMessage<TokenInfo> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 24);

/**
 * @generated from message pathfinder.v1.BasicRoute
 */
export type BasicRoute = Message<"pathfinder.v1.BasicRoute"> & {
  /**
   * @generated from field: string to_chain = 1;
   */
  toChain: string;

  /**
   * @generated from field: string to_chain_id = 2;
   */
  toChainId: string;

  /**
   * @generated from field: string connection_id = 3;
   */
  connectionId: string;

  /**
   * @generated from field: string channel_id = 4;
   */
  channelId: string;

  /**
   * @generated from field: string port_id = 5;
   */
  portId: string;

  /**
   * @generated from field: map<string, pathfinder.v1.TokenInfo> allowed_tokens = 6;
   */
  allowedTokens: { [key: string]: TokenInfo };
};

/**
 * Describes the message pathfinder.v1.BasicRoute.
 * Use `create(BasicRouteSchema)` to create a new message.
 */
export const BasicRouteSchema: GenMessage<BasicRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 25);

/**
 * @generated from message pathfinder.v1.WasmData
 */
export type WasmData = Message<"pathfinder.v1.WasmData"> & {
  /**
   * @generated from field: string contract = 1;
   */
  contract: string;

  /**
   * @generated from field: pathfinder.v1.WasmMsg msg = 2;
   */
  msg?: WasmMsg;
};

/**
 * Describes the message pathfinder.v1.WasmData.
 * Use `create(WasmDataSchema)` to create a new message.
 */
export const WasmDataSchema: GenMessage<WasmData> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 26);

/**
 * @generated from message pathfinder.v1.WasmMsg
 */
export type WasmMsg = Message<"pathfinder.v1.WasmMsg"> & {
  /**
   * @generated from field: pathfinder.v1.SwapAndAction swap_and_action = 1;
   */
  swapAndAction?: SwapAndAction;
};

/**
 * Describes the message pathfinder.v1.WasmMsg.
 * Use `create(WasmMsgSchema)` to create a new message.
 */
export const WasmMsgSchema: GenMessage<WasmMsg> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 27);

/**
 * @generated from message pathfinder.v1.SwapAndAction
 */
export type SwapAndAction = Message<"pathfinder.v1.SwapAndAction"> & {
  /**
   * SwapAndAction is the entry point contract message structure
   *
   * @generated from field: pathfinder.v1.UserSwap user_swap = 1;
   */
  userSwap?: UserSwap;

  /**
   * @generated from field: pathfinder.v1.MinAsset min_asset = 2;
   */
  minAsset?: MinAsset;

  /**
   * @generated from field: int64 timeout_timestamp = 3;
   */
  timeoutTimestamp: bigint;

  /**
   * @generated from field: pathfinder.v1.PostSwapAction post_swap_action = 4;
   */
  postSwapAction?: PostSwapAction;

  /**
   * @generated from field: repeated string affiliates = 5;
   */
  affiliates: string[];
};

/**
 * Describes the message pathfinder.v1.SwapAndAction.
 * Use `create(SwapAndActionSchema)` to create a new message.
 */
export const SwapAndActionSchema: GenMessage<SwapAndAction> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 28);

/**
 * @generated from message pathfinder.v1.SwapExactAssetIn
 */
export type SwapExactAssetIn = Message<"pathfinder.v1.SwapExactAssetIn"> & {
  /**
   * @generated from field: string swap_venue_name = 1;
   */
  swapVenueName: string;

  /**
   * @generated from field: repeated pathfinder.v1.SwapOperation operations = 2;
   */
  operations: SwapOperation[];
};

/**
 * Describes the message pathfinder.v1.SwapExactAssetIn.
 * Use `create(SwapExactAssetInSchema)` to create a new message.
 */
export const SwapExactAssetInSchema: GenMessage<SwapExactAssetIn> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 29);

/**
 * @generated from message pathfinder.v1.SwapOperation
 */
export type SwapOperation = Message<"pathfinder.v1.SwapOperation"> & {
  /**
   * @generated from field: string pool = 1;
   */
  pool: string;

  /**
   * @generated from field: string denom_in = 2;
   */
  denomIn: string;

  /**
   * @generated from field: string denom_out = 3;
   */
  denomOut: string;

  /**
   * Interface is used by some DEXs (like Injective), optional
   *
   * @generated from field: optional string interface = 4;
   */
  interface?: string;
};

/**
 * Describes the message pathfinder.v1.SwapOperation.
 * Use `create(SwapOperationSchema)` to create a new message.
 */
export const SwapOperationSchema: GenMessage<SwapOperation> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 30);

/**
 * @generated from message pathfinder.v1.MinAsset
 */
export type MinAsset = Message<"pathfinder.v1.MinAsset"> & {
  /**
   * @generated from field: pathfinder.v1.Asset native = 1;
   */
  native?: Asset;
};

/**
 * Describes the message pathfinder.v1.MinAsset.
 * Use `create(MinAssetSchema)` to create a new message.
 */
export const MinAssetSchema: GenMessage<MinAsset> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 31);

/**
 * @generated from message pathfinder.v1.Asset
 */
export type Asset = Message<"pathfinder.v1.Asset"> & {
  /**
   * @generated from field: string amount = 1;
   */
  amount: string;

  /**
   * @generated from field: string denom = 2;
   */
  denom: string;
};

/**
 * Describes the message pathfinder.v1.Asset.
 * Use `create(AssetSchema)` to create a new message.
 */
export const AssetSchema: GenMessage<Asset> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 32);

/**
 * @generated from message pathfinder.v1.PostSwapAction
 */
export type PostSwapAction = Message<"pathfinder.v1.PostSwapAction"> & {
  /**
   * @generated from oneof pathfinder.v1.PostSwapAction.action
   */
  action: {
    /**
     * @generated from field: pathfinder.v1.IBCTransfer ibc_transfer = 1;
     */
    value: IBCTransfer;
    case: "ibcTransfer";
  } | {
    /**
     * @generated from field: pathfinder.v1.Transfer transfer = 2;
     */
    value: Transfer;
    case: "transfer";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message pathfinder.v1.PostSwapAction.
 * Use `create(PostSwapActionSchema)` to create a new message.
 */
export const PostSwapActionSchema: GenMessage<PostSwapAction> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 33);

/**
 * @generated from message pathfinder.v1.IBCTransfer
 */
export type IBCTransfer = Message<"pathfinder.v1.IBCTransfer"> & {
  /**
   * @generated from field: pathfinder.v1.IBCInfo ibc_info = 1;
   */
  ibcInfo?: IBCInfo;
};

/**
 * Describes the message pathfinder.v1.IBCTransfer.
 * Use `create(IBCTransferSchema)` to create a new message.
 */
export const IBCTransferSchema: GenMessage<IBCTransfer> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 34);

/**
 * @generated from message pathfinder.v1.Transfer
 */
export type Transfer = Message<"pathfinder.v1.Transfer"> & {
  /**
   * @generated from field: string to_address = 1;
   */
  toAddress: string;
};

/**
 * Describes the message pathfinder.v1.Transfer.
 * Use `create(TransferSchema)` to create a new message.
 */
export const TransferSchema: GenMessage<Transfer> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 35);

/**
 * @generated from message pathfinder.v1.IBCInfo
 */
export type IBCInfo = Message<"pathfinder.v1.IBCInfo"> & {
  /**
   * @generated from field: string memo = 1;
   */
  memo: string;

  /**
   * @generated from field: string receiver = 2;
   */
  receiver: string;

  /**
   * @generated from field: string recover_address = 3;
   */
  recoverAddress: string;

  /**
   * @generated from field: string source_channel = 4;
   */
  sourceChannel: string;
};

/**
 * Describes the message pathfinder.v1.IBCInfo.
 * Use `create(IBCInfoSchema)` to create a new message.
 */
export const IBCInfoSchema: GenMessage<IBCInfo> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 36);

/**
 * @generated from message pathfinder.v1.UserSwap
 */
export type UserSwap = Message<"pathfinder.v1.UserSwap"> & {
  /**
   * @generated from field: pathfinder.v1.SwapExactAssetIn swap_exact_asset_in = 1;
   */
  swapExactAssetIn?: SwapExactAssetIn;
};

/**
 * Describes the message pathfinder.v1.UserSwap.
 * Use `create(UserSwapSchema)` to create a new message.
 */
export const UserSwapSchema: GenMessage<UserSwap> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 37);

/**
 * PathfinderService provides route discovery and validation for IBC transfers and swaps
 *
 * @generated from service pathfinder.v1.PathfinderService
 */
export const PathfinderService: GenService<{
  /**
   * FindPath finds and validates a route between two chains
   * Supports human-readable denoms (e.g., "uatone") or IBC denoms
   *
   * @generated from rpc pathfinder.v1.PathfinderService.FindPath
   */
  findPath: {
    methodKind: "unary";
    input: typeof FindPathRequestSchema;
    output: typeof FindPathResponseSchema;
  },
  /**
   * LookupDenom resolves denom information on a specific chain
   * Accepts human-readable base denoms or IBC denom hashes
   *
   * @generated from rpc pathfinder.v1.PathfinderService.LookupDenom
   */
  lookupDenom: {
    methodKind: "unary";
    input: typeof LookupDenomRequestSchema;
    output: typeof LookupDenomResponseSchema;
  },
  /**
   * GetTokenDenoms returns all IBC denoms for a token across supported chains
   * Use this to discover what denom a token has on different chains
   *
   * @generated from rpc pathfinder.v1.PathfinderService.GetTokenDenoms
   */
  getTokenDenoms: {
    methodKind: "unary";
    input: typeof GetTokenDenomsRequestSchema;
    output: typeof GetTokenDenomsResponseSchema;
  },
  /**
   * GetChainInfo returns information about a specific chain
   *
   * @generated from rpc pathfinder.v1.PathfinderService.GetChainInfo
   */
  getChainInfo: {
    methodKind: "unary";
    input: typeof ChainInfoRequestSchema;
    output: typeof ChainInfoResponseSchema;
  },
  /**
   * ListSupportedChains returns a list of supported chains
   *
   * @generated from rpc pathfinder.v1.PathfinderService.ListSupportedChains
   */
  listSupportedChains: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof PathfinderSupportedChainsResponseSchema;
  },
  /**
   * GetChainTokens returns all tokens available on a specific chain
   * Includes both native tokens and IBC tokens with their denoms
   *
   * @generated from rpc pathfinder.v1.PathfinderService.GetChainTokens
   */
  getChainTokens: {
    methodKind: "unary";
    input: typeof GetChainTokensRequestSchema;
    output: typeof GetChainTokensResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_pathfinder_route, 0);

