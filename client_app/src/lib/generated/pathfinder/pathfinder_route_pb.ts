// @generated by protoc-gen-es v2.10.2 with parameter "target=ts"
// @generated from file pathfinder_route.proto (package pathfinder.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_buf_validate_validate } from "./buf/validate/validate_pb";
import type { EmptySchema } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file pathfinder_route.proto.
 */
export const file_pathfinder_route: GenFile = /*@__PURE__*/
  fileDesc("ChZwYXRoZmluZGVyX3JvdXRlLnByb3RvEg1wYXRoZmluZGVyLnYxIrUCCg9GaW5kUGF0aFJlcXVlc3QSGgoKY2hhaW5fZnJvbRgBIAEoCUIGukgDyAEBEicKEHRva2VuX2Zyb21fZGVub20YAiABKAlCDbpICsgBAXIFEAEYgAESGQoJYW1vdW50X2luGAMgASgJQga6SAPIAQESGAoIY2hhaW5fdG8YBCABKAlCBrpIA8gBARIgCg50b2tlbl90b19kZW5vbRgFIAEoCUIIukgFcgMYgAESJAoOc2VuZGVyX2FkZHJlc3MYBiABKAlCDLpICcgBAXIEECYYRBImChByZWNlaXZlcl9hZGRyZXNzGAcgASgJQgy6SAnIAQFyBBAmGEQSEwoLc21hcnRfcm91dGUYCCABKAgSIwoMc2xpcHBhZ2VfYnBzGAkgASgNQg26SArIAQAqBRiQTigAIvYBChBGaW5kUGF0aFJlc3BvbnNlEg8KB3N1Y2Nlc3MYASABKAgSJAoNZXJyb3JfbWVzc2FnZRgCIAEoCVINZXJyb3JfbWVzc2FnZRIsCgZkaXJlY3QYAyABKAsyGi5wYXRoZmluZGVyLnYxLkRpcmVjdFJvdXRlSAASMAoIaW5kaXJlY3QYBCABKAsyHC5wYXRoZmluZGVyLnYxLkluZGlyZWN0Um91dGVIABJCCgticm9rZXJfc3dhcBgFIAEoCzIeLnBhdGhmaW5kZXIudjEuQnJva2VyU3dhcFJvdXRlSABSC2Jyb2tlcl9zd2FwQgcKBXJvdXRlIjYKC0RpcmVjdFJvdXRlEicKCHRyYW5zZmVyGAEgASgLMhUucGF0aGZpbmRlci52MS5JQkNMZWcirAEKDUluZGlyZWN0Um91dGUSDAoEcGF0aBgBIAMoCRIjCgRsZWdzGAIgAygLMhUucGF0aGZpbmRlci52MS5JQkNMZWcSIgoMc3VwcG9ydHNfcGZtGAMgASgIUgxzdXBwb3J0c19wZm0SKAoPcGZtX3N0YXJ0X2NoYWluGAQgASgJUg9wZm1fc3RhcnRfY2hhaW4SGgoIcGZtX21lbW8YBSABKAlSCHBmbV9tZW1vIqwCCg9Ccm9rZXJTd2FwUm91dGUSDAoEcGF0aBgBIAMoCRI5CgxpbmJvdW5kX2xlZ3MYAiADKAsyFS5wYXRoZmluZGVyLnYxLklCQ0xlZ1IMaW5ib3VuZF9sZWdzEiYKBHN3YXAYAyABKAsyGC5wYXRoZmluZGVyLnYxLlN3YXBRdW90ZRI7Cg1vdXRib3VuZF9sZWdzGAQgAygLMhUucGF0aGZpbmRlci52MS5JQkNMZWdSDW91dGJvdW5kX2xlZ3MSNAoVb3V0Ym91bmRfc3VwcG9ydHNfcGZtGAUgASgIUhVvdXRib3VuZF9zdXBwb3J0c19wZm0SNQoJZXhlY3V0aW9uGAYgASgLMiIucGF0aGZpbmRlci52MS5Ccm9rZXJFeGVjdXRpb25EYXRhIt4CChNCcm9rZXJFeGVjdXRpb25EYXRhEhEKBG1lbW8YASABKAlIAIgBARJOChNzbWFydF9jb250cmFjdF9kYXRhGAIgASgLMhcucGF0aGZpbmRlci52MS5XYXNtRGF0YUgBUhNzbWFydF9jb250cmFjdF9kYXRhiAEBEicKDGliY19yZWNlaXZlchgDIAEoCUgCUgxpYmNfcmVjZWl2ZXKIAQESKAoPcmVjb3Zlcl9hZGRyZXNzGAQgASgJUg9yZWNvdmVyX2FkZHJlc3MSLAoRbWluX291dHB1dF9hbW91bnQYBSABKAlSEW1pbl9vdXRwdXRfYW1vdW50EhwKCXVzZXNfd2FzbRgGIAEoCFIJdXNlc193YXNtEhMKC2Rlc2NyaXB0aW9uGAcgASgJQgcKBV9tZW1vQhYKFF9zbWFydF9jb250cmFjdF9kYXRhQg8KDV9pYmNfcmVjZWl2ZXIinwEKBklCQ0xlZxIeCgpmcm9tX2NoYWluGAEgASgJUgpmcm9tX2NoYWluEhoKCHRvX2NoYWluGAIgASgJUgh0b19jaGFpbhIPCgdjaGFubmVsGAMgASgJEgwKBHBvcnQYBCABKAkSKgoFdG9rZW4YBSABKAsyGy5wYXRoZmluZGVyLnYxLlRva2VuTWFwcGluZxIOCgZhbW91bnQYBiABKAkikgEKDFRva2VuTWFwcGluZxIgCgtjaGFpbl9kZW5vbRgBIAEoCVILY2hhaW5fZGVub20SHgoKYmFzZV9kZW5vbRgCIAEoCVIKYmFzZV9kZW5vbRIiCgxvcmlnaW5fY2hhaW4YAyABKAlSDG9yaWdpbl9jaGFpbhIcCglpc19uYXRpdmUYBCABKAhSCWlzX25hdGl2ZSL4AgoJU3dhcFF1b3RlEg4KBmJyb2tlchgBIAEoCRI3Cgh0b2tlbl9pbhgCIAEoCzIbLnBhdGhmaW5kZXIudjEuVG9rZW5NYXBwaW5nUgh0b2tlbl9pbhI5Cgl0b2tlbl9vdXQYAyABKAsyGy5wYXRoZmluZGVyLnYxLlRva2VuTWFwcGluZ1IJdG9rZW5fb3V0EhwKCWFtb3VudF9pbhgEIAEoCVIJYW1vdW50X2luEh4KCmFtb3VudF9vdXQYBSABKAlSCmFtb3VudF9vdXQSIgoMcHJpY2VfaW1wYWN0GAYgASgJUgxwcmljZV9pbXBhY3QSJAoNZWZmZWN0aXZlX2ZlZRgHIAEoCVINZWZmZWN0aXZlX2ZlZRJRChJvc21vc2lzX3JvdXRlX2RhdGEYCCABKAsyHy5wYXRoZmluZGVyLnYxLk9zbW9zaXNSb3V0ZURhdGFIAFISb3Ntb3Npc19yb3V0ZV9kYXRhQgwKCnJvdXRlX2RhdGEinQEKEE9zbW9zaXNSb3V0ZURhdGESKwoGcm91dGVzGAEgAygLMhsucGF0aGZpbmRlci52MS5Pc21vc2lzUm91dGUSJAoNbGlxdWlkaXR5X2NhcBgCIAEoCVINbGlxdWlkaXR5X2NhcBI2ChZsaXF1aWRpdHlfY2FwX292ZXJmbG93GAMgASgIUhZsaXF1aWRpdHlfY2FwX292ZXJmbG93IpkBCgxPc21vc2lzUm91dGUSKQoFcG9vbHMYASADKAsyGi5wYXRoZmluZGVyLnYxLk9zbW9zaXNQb29sEiAKC2hhc19jd19wb29sGAIgASgIUgtoYXNfY3dfcG9vbBIeCgpvdXRfYW1vdW50GAMgASgJUgpvdXRfYW1vdW50EhwKCWluX2Ftb3VudBgEIAEoCVIJaW5fYW1vdW50IrsBCgtPc21vc2lzUG9vbBIKCgJpZBgBIAEoBRIMCgR0eXBlGAIgASgFEiQKDXNwcmVhZF9mYWN0b3IYAyABKAlSDXNwcmVhZF9mYWN0b3ISKAoPdG9rZW5fb3V0X2Rlbm9tGAQgASgJUg90b2tlbl9vdXRfZGVub20SHAoJdGFrZXJfZmVlGAUgASgJUgl0YWtlcl9mZWUSJAoNbGlxdWlkaXR5X2NhcBgGIAEoCVINbGlxdWlkaXR5X2NhcCJMChJMb29rdXBEZW5vbVJlcXVlc3QSGAoIY2hhaW5faWQYASABKAlCBrpIA8gBARIcCgVkZW5vbRgCIAEoCUINukgKyAEBcgUQARiAASKDAgoTTG9va3VwRGVub21SZXNwb25zZRINCgVmb3VuZBgBIAEoCBIgCgtjaGFpbl9kZW5vbRgCIAEoCVILY2hhaW5fZGVub20SHgoKYmFzZV9kZW5vbRgDIAEoCVIKYmFzZV9kZW5vbRIiCgxvcmlnaW5fY2hhaW4YBCABKAlSDG9yaWdpbl9jaGFpbhIcCglpc19uYXRpdmUYBSABKAhSCWlzX25hdGl2ZRIaCghpYmNfcGF0aBgGIAEoCVIIaWJjX3BhdGgSPQoMYXZhaWxhYmxlX29uGAcgAygLMhkucGF0aGZpbmRlci52MS5DaGFpbkRlbm9tUgxhdmFpbGFibGVfb24idQoKQ2hhaW5EZW5vbRIaCghjaGFpbl9pZBgBIAEoCVIIY2hhaW5faWQSHgoKY2hhaW5fbmFtZRgCIAEoCVIKY2hhaW5fbmFtZRINCgVkZW5vbRgDIAEoCRIcCglpc19uYXRpdmUYBCABKAhSCWlzX25hdGl2ZSJmChVHZXRUb2tlbkRlbm9tc1JlcXVlc3QSGgoKYmFzZV9kZW5vbRgBIAEoCUIGukgDyAEBEhwKDG9yaWdpbl9jaGFpbhgCIAEoCUIGukgDyAEBEhMKC29uX2NoYWluX2lkGAMgASgJIpYBChZHZXRUb2tlbkRlbm9tc1Jlc3BvbnNlEg0KBWZvdW5kGAEgASgIEh4KCmJhc2VfZGVub20YAiABKAlSCmJhc2VfZGVub20SIgoMb3JpZ2luX2NoYWluGAMgASgJUgxvcmlnaW5fY2hhaW4SKQoGZGVub21zGAQgAygLMhkucGF0aGZpbmRlci52MS5DaGFpbkRlbm9tIjEKFUdldENoYWluVG9rZW5zUmVxdWVzdBIYCghjaGFpbl9pZBgBIAEoCUIGukgDyAEBItQBChZHZXRDaGFpblRva2Vuc1Jlc3BvbnNlEhoKCGNoYWluX2lkGAEgASgJUghjaGFpbl9pZBIeCgpjaGFpbl9uYW1lGAIgASgJUgpjaGFpbl9uYW1lEkEKDW5hdGl2ZV90b2tlbnMYAyADKAsyGy5wYXRoZmluZGVyLnYxLlRva2VuRGV0YWlsc1INbmF0aXZlX3Rva2VucxI7CgppYmNfdG9rZW5zGAQgAygLMhsucGF0aGZpbmRlci52MS5Ub2tlbkRldGFpbHNSCmliY190b2tlbnMioQEKDFRva2VuRGV0YWlscxINCgVkZW5vbRgBIAEoCRIOCgZzeW1ib2wYAiABKAkSHgoKYmFzZV9kZW5vbRgDIAEoCVIKYmFzZV9kZW5vbRIiCgxvcmlnaW5fY2hhaW4YBCABKAlSDG9yaWdpbl9jaGFpbhIQCghkZWNpbWFscxgFIAEoBRIcCglpc19uYXRpdmUYBiABKAhSCWlzX25hdGl2ZSJJCiFQYXRoZmluZGVyU3VwcG9ydGVkQ2hhaW5zUmVzcG9uc2USJAoJY2hhaW5faWRzGAEgAygJQga6SAPIAQFSCWNoYWluX2lkcyJCChBDaGFpbkluZm9SZXF1ZXN0EhgKCGNoYWluX2lkGAEgASgJQga6SAPIAQESFAoMc2hvd19zeW1ib2xzGAIgASgIIk0KEUNoYWluSW5mb1Jlc3BvbnNlEjgKCmNoYWluX2luZm8YASABKAsyGC5wYXRoZmluZGVyLnYxLkNoYWluSW5mb1IKY2hhaW5faW5mbyKqAQoJQ2hhaW5JbmZvEhoKCGNoYWluX2lkGAEgASgJUghjaGFpbl9pZBIeCgpjaGFpbl9uYW1lGAIgASgJUgpjaGFpbl9uYW1lEhgKB2hhc19wZm0YAyABKAhSB2hhc19wZm0SHAoJaXNfYnJva2VyGAQgASgIUglpc19icm9rZXISKQoGcm91dGVzGAUgAygLMhkucGF0aGZpbmRlci52MS5CYXNpY1JvdXRlIrEBCglUb2tlbkluZm8SIAoLY2hhaW5fZGVub20YASABKAlSC2NoYWluX2Rlbm9tEhwKCWliY19kZW5vbRgCIAEoCVIJaWJjX2Rlbm9tEh4KCmJhc2VfZGVub20YAyABKAlSCmJhc2VfZGVub20SIgoMb3JpZ2luX2NoYWluGAQgASgJUgxvcmlnaW5fY2hhaW4SEAoIZGVjaW1hbHMYBSABKAUSDgoGc3ltYm9sGAYgASgJItACCgpCYXNpY1JvdXRlEhoKCHRvX2NoYWluGAEgASgJUgh0b19jaGFpbhIgCgt0b19jaGFpbl9pZBgCIAEoCVILdG9fY2hhaW5faWQSJAoNY29ubmVjdGlvbl9pZBgDIAEoCVINY29ubmVjdGlvbl9pZBIeCgpjaGFubmVsX2lkGAQgASgJUgpjaGFubmVsX2lkEhgKB3BvcnRfaWQYBSABKAlSB3BvcnRfaWQSVAoOYWxsb3dlZF90b2tlbnMYBiADKAsyLC5wYXRoZmluZGVyLnYxLkJhc2ljUm91dGUuQWxsb3dlZFRva2Vuc0VudHJ5Ug5hbGxvd2VkX3Rva2VucxpOChJBbGxvd2VkVG9rZW5zRW50cnkSCwoDa2V5GAEgASgJEicKBXZhbHVlGAIgASgLMhgucGF0aGZpbmRlci52MS5Ub2tlbkluZm86AjgBIkEKCFdhc21EYXRhEhAKCGNvbnRyYWN0GAEgASgJEiMKA21zZxgCIAEoCzIWLnBhdGhmaW5kZXIudjEuV2FzbU1zZyJRCgdXYXNtTXNnEkYKD3N3YXBfYW5kX2FjdGlvbhgBIAEoCzIcLnBhdGhmaW5kZXIudjEuU3dhcEFuZEFjdGlvblIPc3dhcF9hbmRfYWN0aW9uIooCCg1Td2FwQW5kQWN0aW9uEjUKCXVzZXJfc3dhcBgBIAEoCzIXLnBhdGhmaW5kZXIudjEuVXNlclN3YXBSCXVzZXJfc3dhcBI1CgltaW5fYXNzZXQYAiABKAsyFy5wYXRoZmluZGVyLnYxLk1pbkFzc2V0UgltaW5fYXNzZXQSLAoRdGltZW91dF90aW1lc3RhbXAYAyABKANSEXRpbWVvdXRfdGltZXN0YW1wEkkKEHBvc3Rfc3dhcF9hY3Rpb24YBCABKAsyHS5wYXRoZmluZGVyLnYxLlBvc3RTd2FwQWN0aW9uUhBwb3N0X3N3YXBfYWN0aW9uEhIKCmFmZmlsaWF0ZXMYBSADKAkibgoQU3dhcEV4YWN0QXNzZXRJbhIoCg9zd2FwX3ZlbnVlX25hbWUYASABKAlSD3N3YXBfdmVudWVfbmFtZRIwCgpvcGVyYXRpb25zGAIgAygLMhwucGF0aGZpbmRlci52MS5Td2FwT3BlcmF0aW9uIn0KDVN3YXBPcGVyYXRpb24SDAoEcG9vbBgBIAEoCRIaCghkZW5vbV9pbhgCIAEoCVIIZGVub21faW4SHAoJZGVub21fb3V0GAMgASgJUglkZW5vbV9vdXQSFgoJaW50ZXJmYWNlGAQgASgJSACIAQFCDAoKX2ludGVyZmFjZSIwCghNaW5Bc3NldBIkCgZuYXRpdmUYASABKAsyFC5wYXRoZmluZGVyLnYxLkFzc2V0IiYKBUFzc2V0Eg4KBmFtb3VudBgBIAEoCRINCgVkZW5vbRgCIAEoCSKJAQoOUG9zdFN3YXBBY3Rpb24SQAoMaWJjX3RyYW5zZmVyGAEgASgLMhoucGF0aGZpbmRlci52MS5JQkNUcmFuc2ZlckgAUgxpYmNfdHJhbnNmZXISKwoIdHJhbnNmZXIYAiABKAsyFy5wYXRoZmluZGVyLnYxLlRyYW5zZmVySABCCAoGYWN0aW9uIkEKC0lCQ1RyYW5zZmVyEjIKCGliY19pbmZvGAEgASgLMhYucGF0aGZpbmRlci52MS5JQkNJbmZvUghpYmNfaW5mbyIqCghUcmFuc2ZlchIeCgp0b19hZGRyZXNzGAEgASgJUgp0b19hZGRyZXNzInsKB0lCQ0luZm8SDAoEbWVtbxgBIAEoCRIQCghyZWNlaXZlchgCIAEoCRIoCg9yZWNvdmVyX2FkZHJlc3MYAyABKAlSD3JlY292ZXJfYWRkcmVzcxImCg5zb3VyY2VfY2hhbm5lbBgEIAEoCVIOc291cmNlX2NoYW5uZWwiXQoIVXNlclN3YXASUQoTc3dhcF9leGFjdF9hc3NldF9pbhgBIAEoCzIfLnBhdGhmaW5kZXIudjEuU3dhcEV4YWN0QXNzZXRJblITc3dhcF9leGFjdF9hc3NldF9pbjLGBAoRUGF0aGZpbmRlclNlcnZpY2USUAoIRmluZFBhdGgSHi5wYXRoZmluZGVyLnYxLkZpbmRQYXRoUmVxdWVzdBofLnBhdGhmaW5kZXIudjEuRmluZFBhdGhSZXNwb25zZSIDkAIBElkKC0xvb2t1cERlbm9tEiEucGF0aGZpbmRlci52MS5Mb29rdXBEZW5vbVJlcXVlc3QaIi5wYXRoZmluZGVyLnYxLkxvb2t1cERlbm9tUmVzcG9uc2UiA5ACARJiCg5HZXRUb2tlbkRlbm9tcxIkLnBhdGhmaW5kZXIudjEuR2V0VG9rZW5EZW5vbXNSZXF1ZXN0GiUucGF0aGZpbmRlci52MS5HZXRUb2tlbkRlbm9tc1Jlc3BvbnNlIgOQAgESVgoMR2V0Q2hhaW5JbmZvEh8ucGF0aGZpbmRlci52MS5DaGFpbkluZm9SZXF1ZXN0GiAucGF0aGZpbmRlci52MS5DaGFpbkluZm9SZXNwb25zZSIDkAIBEmQKE0xpc3RTdXBwb3J0ZWRDaGFpbnMSFi5nb29nbGUucHJvdG9idWYuRW1wdHkaMC5wYXRoZmluZGVyLnYxLlBhdGhmaW5kZXJTdXBwb3J0ZWRDaGFpbnNSZXNwb25zZSIDkAIBEmIKDkdldENoYWluVG9rZW5zEiQucGF0aGZpbmRlci52MS5HZXRDaGFpblRva2Vuc1JlcXVlc3QaJS5wYXRoZmluZGVyLnYxLkdldENoYWluVG9rZW5zUmVzcG9uc2UiA5ACAUJBWj9naXRodWIuY29tL0NvZ3doZWVsLVZhbGlkYXRvci9zcGVjdHJhLWliYy1odWIvcGF0aGZpbmRlci9ycGMvdjFiBnByb3RvMw", [file_buf_validate_validate, file_google_protobuf_empty]);

/**
 * FindPathRequest - Find a route between chains
 *
 * For token_from_denom and token_to_denom, you can use:
 * - Human-readable denom (e.g., "uatone", "uosmo", "ustars")
 * - Full IBC denom (e.g., "ibc/ABC123...")
 *
 * The pathfinder will automatically resolve human-readable denoms.
 * If token_to_denom is empty, the pathfinder assumes you want the same token
 * on the destination chain (useful for bridging without swapping).
 *
 * @generated from message pathfinder.v1.FindPathRequest
 */
export type FindPathRequest = Message<"pathfinder.v1.FindPathRequest"> & {
  /**
   * Source chain ID (e.g., "osmosis-1", "atomone-1")
   *
   * @generated from field: string chain_from = 1;
   */
  chainFrom: string;

  /**
   * Token denom on source chain - can be human-readable (e.g., "uatone") 
   * or IBC denom (e.g., "ibc/...")
   *
   * @generated from field: string token_from_denom = 2;
   */
  tokenFromDenom: string;

  /**
   * Amount to transfer/swap (in base units)
   *
   * @generated from field: string amount_in = 3;
   */
  amountIn: string;

  /**
   * Destination chain ID
   *
   * @generated from field: string chain_to = 4;
   */
  chainTo: string;

  /**
   * Token denom you want to receive on destination chain
   * Can be human-readable (e.g., "uosmo") or IBC denom
   * If empty, assumes same token as token_from (bridging without swap)
   *
   * @generated from field: string token_to_denom = 5;
   */
  tokenToDenom: string;

  /**
   * Sender address on source chain
   *
   * @generated from field: string sender_address = 6;
   */
  senderAddress: string;

  /**
   * Receiver address on destination chain
   *
   * @generated from field: string receiver_address = 7;
   */
  receiverAddress: string;

  /**
   * If true, return a smart route, if false, return a normal route
   *
   * @generated from field: bool smart_route = 8;
   */
  smartRoute: boolean;

  /**
   * Slippage in basis points (e.g., 100 = 1%, 1000 = 10%)
   * Must be less than 10000
   *
   * @generated from field: uint32 slippage_bps = 9;
   */
  slippageBps: number;
};

/**
 * Describes the message pathfinder.v1.FindPathRequest.
 * Use `create(FindPathRequestSchema)` to create a new message.
 */
export const FindPathRequestSchema: GenMessage<FindPathRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 0);

/**
 * @generated from message pathfinder.v1.FindPathResponse
 */
export type FindPathResponse = Message<"pathfinder.v1.FindPathResponse"> & {
  /**
   * @generated from field: bool success = 1;
   */
  success: boolean;

  /**
   * @generated from field: string error_message = 2 [json_name = "error_message"];
   */
  errorMessage: string;

  /**
   * @generated from oneof pathfinder.v1.FindPathResponse.route
   */
  route: {
    /**
     * @generated from field: pathfinder.v1.DirectRoute direct = 3;
     */
    value: DirectRoute;
    case: "direct";
  } | {
    /**
     * @generated from field: pathfinder.v1.IndirectRoute indirect = 4;
     */
    value: IndirectRoute;
    case: "indirect";
  } | {
    /**
     * @generated from field: pathfinder.v1.BrokerSwapRoute broker_swap = 5 [json_name = "broker_swap"];
     */
    value: BrokerSwapRoute;
    case: "brokerSwap";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message pathfinder.v1.FindPathResponse.
 * Use `create(FindPathResponseSchema)` to create a new message.
 */
export const FindPathResponseSchema: GenMessage<FindPathResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 1);

/**
 * @generated from message pathfinder.v1.DirectRoute
 */
export type DirectRoute = Message<"pathfinder.v1.DirectRoute"> & {
  /**
   * @generated from field: pathfinder.v1.IBCLeg transfer = 1;
   */
  transfer?: IBCLeg;
};

/**
 * Describes the message pathfinder.v1.DirectRoute.
 * Use `create(DirectRouteSchema)` to create a new message.
 */
export const DirectRouteSchema: GenMessage<DirectRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 2);

/**
 * @generated from message pathfinder.v1.IndirectRoute
 */
export type IndirectRoute = Message<"pathfinder.v1.IndirectRoute"> & {
  /**
   * @generated from field: repeated string path = 1;
   */
  path: string[];

  /**
   * @generated from field: repeated pathfinder.v1.IBCLeg legs = 2;
   */
  legs: IBCLeg[];

  /**
   * @generated from field: bool supports_pfm = 3 [json_name = "supports_pfm"];
   */
  supportsPfm: boolean;

  /**
   * @generated from field: string pfm_start_chain = 4 [json_name = "pfm_start_chain"];
   */
  pfmStartChain: string;

  /**
   * @generated from field: string pfm_memo = 5 [json_name = "pfm_memo"];
   */
  pfmMemo: string;
};

/**
 * Describes the message pathfinder.v1.IndirectRoute.
 * Use `create(IndirectRouteSchema)` to create a new message.
 */
export const IndirectRouteSchema: GenMessage<IndirectRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 3);

/**
 * BrokerSwapRoute represents a route involving a swap on a broker chain.
 * Supports various scenarios:
 * - Same-chain swap: inbound_leg absent, outbound_legs=[] (e.g., osmosis ATOM -> osmosis OSMO)
 * - Swap from broker: inbound_leg absent (e.g., osmosis USDC -> juno JUNO)
 * - Standard 3-chain: inbound_leg set, len(outbound_legs)=1
 * - Multi-hop outbound: inbound_leg set, len(outbound_legs)>1 (e.g., cosmos ATOM -> swap -> noble -> juno)
 *
 * @generated from message pathfinder.v1.BrokerSwapRoute
 */
export type BrokerSwapRoute = Message<"pathfinder.v1.BrokerSwapRoute"> & {
  /**
   * All chain IDs in order
   *
   * @generated from field: repeated string path = 1;
   */
  path: string[];

  /**
   * IBC transfer to reach broker (absent if starting from broker)
   *
   * @generated from field: repeated pathfinder.v1.IBCLeg inbound_legs = 2 [json_name = "inbound_legs"];
   */
  inboundLegs: IBCLeg[];

  /**
   * The swap operation on the broker chain
   *
   * @generated from field: pathfinder.v1.SwapQuote swap = 3;
   */
  swap?: SwapQuote;

  /**
   * IBC transfers after swap (empty if destination is broker)
   * Can be multiple for multi-hop forwarding via PFM
   *
   * @generated from field: repeated pathfinder.v1.IBCLeg outbound_legs = 4 [json_name = "outbound_legs"];
   */
  outboundLegs: IBCLeg[];

  /**
   * Can use PFM for outbound legs
   *
   * @generated from field: bool outbound_supports_pfm = 5 [json_name = "outbound_supports_pfm"];
   */
  outboundSupportsPfm: boolean;

  /**
   * Execution data for building transactions
   *
   * @generated from field: pathfinder.v1.BrokerExecutionData execution = 6;
   */
  execution?: BrokerExecutionData;
};

/**
 * Describes the message pathfinder.v1.BrokerSwapRoute.
 * Use `create(BrokerSwapRouteSchema)` to create a new message.
 */
export const BrokerSwapRouteSchema: GenMessage<BrokerSwapRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 4);

/**
 * BrokerExecutionData contains ready-to-use transaction data
 *
 * @generated from message pathfinder.v1.BrokerExecutionData
 */
export type BrokerExecutionData = Message<"pathfinder.v1.BrokerExecutionData"> & {
  /**
   * The IBC memo to use with MsgTransfer (contains wasm swap_and_action)
   *
   * @generated from field: optional string memo = 1;
   */
  memo?: string;

  /**
   * The smart contract data to use with the swap and transfer
   *
   * @generated from field: optional pathfinder.v1.WasmData smart_contract_data = 2 [json_name = "smart_contract_data"];
   */
  smartContractData?: WasmData;

  /**
   * Receiver address for MsgTransfer (the ibc-hooks contract)
   *
   * @generated from field: optional string ibc_receiver = 3 [json_name = "ibc_receiver"];
   */
  ibcReceiver?: string;

  /**
   * Recovery address on broker chain (where funds go if swap/forward fails)
   *
   * @generated from field: string recover_address = 4 [json_name = "recover_address"];
   */
  recoverAddress: string;

  /**
   * Minimum output amount after slippage (1% default)
   *
   * @generated from field: string min_output_amount = 5 [json_name = "min_output_amount"];
   */
  minOutputAmount: string;

  /**
   * True if using wasm ibc-hooks (vs simple PFM)
   *
   * @generated from field: bool uses_wasm = 6 [json_name = "uses_wasm"];
   */
  usesWasm: boolean;

  /**
   * Human-readable description
   *
   * @generated from field: string description = 7;
   */
  description: string;
};

/**
 * Describes the message pathfinder.v1.BrokerExecutionData.
 * Use `create(BrokerExecutionDataSchema)` to create a new message.
 */
export const BrokerExecutionDataSchema: GenMessage<BrokerExecutionData> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 5);

/**
 * @generated from message pathfinder.v1.IBCLeg
 */
export type IBCLeg = Message<"pathfinder.v1.IBCLeg"> & {
  /**
   * @generated from field: string from_chain = 1 [json_name = "from_chain"];
   */
  fromChain: string;

  /**
   * @generated from field: string to_chain = 2 [json_name = "to_chain"];
   */
  toChain: string;

  /**
   * @generated from field: string channel = 3;
   */
  channel: string;

  /**
   * @generated from field: string port = 4;
   */
  port: string;

  /**
   * @generated from field: pathfinder.v1.TokenMapping token = 5;
   */
  token?: TokenMapping;

  /**
   * @generated from field: string amount = 6;
   */
  amount: string;
};

/**
 * Describes the message pathfinder.v1.IBCLeg.
 * Use `create(IBCLegSchema)` to create a new message.
 */
export const IBCLegSchema: GenMessage<IBCLeg> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 6);

/**
 * @generated from message pathfinder.v1.TokenMapping
 */
export type TokenMapping = Message<"pathfinder.v1.TokenMapping"> & {
  /**
   * The denom as it appears on the current chain (native or IBC)
   *
   * @generated from field: string chain_denom = 1 [json_name = "chain_denom"];
   */
  chainDenom: string;

  /**
   * The base/native denom on the token's origin chain
   *
   * @generated from field: string base_denom = 2 [json_name = "base_denom"];
   */
  baseDenom: string;

  /**
   * The chain ID where this token is native
   *
   * @generated from field: string origin_chain = 3 [json_name = "origin_chain"];
   */
  originChain: string;

  /**
   * True if this is the token's native chain
   *
   * @generated from field: bool is_native = 4 [json_name = "is_native"];
   */
  isNative: boolean;
};

/**
 * Describes the message pathfinder.v1.TokenMapping.
 * Use `create(TokenMappingSchema)` to create a new message.
 */
export const TokenMappingSchema: GenMessage<TokenMapping> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 7);

/**
 * SwapQuote with broker-specific route data
 *
 * @generated from message pathfinder.v1.SwapQuote
 */
export type SwapQuote = Message<"pathfinder.v1.SwapQuote"> & {
  /**
   * @generated from field: string broker = 1;
   */
  broker: string;

  /**
   * @generated from field: pathfinder.v1.TokenMapping token_in = 2 [json_name = "token_in"];
   */
  tokenIn?: TokenMapping;

  /**
   * @generated from field: pathfinder.v1.TokenMapping token_out = 3 [json_name = "token_out"];
   */
  tokenOut?: TokenMapping;

  /**
   * @generated from field: string amount_in = 4 [json_name = "amount_in"];
   */
  amountIn: string;

  /**
   * @generated from field: string amount_out = 5 [json_name = "amount_out"];
   */
  amountOut: string;

  /**
   * @generated from field: string price_impact = 6 [json_name = "price_impact"];
   */
  priceImpact: string;

  /**
   * @generated from field: string effective_fee = 7 [json_name = "effective_fee"];
   */
  effectiveFee: string;

  /**
   * Broker-specific route data using oneof for type safety
   *
   * @generated from oneof pathfinder.v1.SwapQuote.route_data
   */
  routeData: {
    /**
     * Future brokers can be added here without breaking existing clients
     *
     * @generated from field: pathfinder.v1.OsmosisRouteData osmosis_route_data = 8 [json_name = "osmosis_route_data"];
     */
    value: OsmosisRouteData;
    case: "osmosisRouteData";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message pathfinder.v1.SwapQuote.
 * Use `create(SwapQuoteSchema)` to create a new message.
 */
export const SwapQuoteSchema: GenMessage<SwapQuote> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 8);

/**
 * Osmosis-specific route data (from SQS API)
 *
 * @generated from message pathfinder.v1.OsmosisRouteData
 */
export type OsmosisRouteData = Message<"pathfinder.v1.OsmosisRouteData"> & {
  /**
   * @generated from field: repeated pathfinder.v1.OsmosisRoute routes = 1;
   */
  routes: OsmosisRoute[];

  /**
   * @generated from field: string liquidity_cap = 2 [json_name = "liquidity_cap"];
   */
  liquidityCap: string;

  /**
   * @generated from field: bool liquidity_cap_overflow = 3 [json_name = "liquidity_cap_overflow"];
   */
  liquidityCapOverflow: boolean;
};

/**
 * Describes the message pathfinder.v1.OsmosisRouteData.
 * Use `create(OsmosisRouteDataSchema)` to create a new message.
 */
export const OsmosisRouteDataSchema: GenMessage<OsmosisRouteData> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 9);

/**
 * @generated from message pathfinder.v1.OsmosisRoute
 */
export type OsmosisRoute = Message<"pathfinder.v1.OsmosisRoute"> & {
  /**
   * @generated from field: repeated pathfinder.v1.OsmosisPool pools = 1;
   */
  pools: OsmosisPool[];

  /**
   * @generated from field: bool has_cw_pool = 2 [json_name = "has_cw_pool"];
   */
  hasCwPool: boolean;

  /**
   * @generated from field: string out_amount = 3 [json_name = "out_amount"];
   */
  outAmount: string;

  /**
   * @generated from field: string in_amount = 4 [json_name = "in_amount"];
   */
  inAmount: string;
};

/**
 * Describes the message pathfinder.v1.OsmosisRoute.
 * Use `create(OsmosisRouteSchema)` to create a new message.
 */
export const OsmosisRouteSchema: GenMessage<OsmosisRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 10);

/**
 * @generated from message pathfinder.v1.OsmosisPool
 */
export type OsmosisPool = Message<"pathfinder.v1.OsmosisPool"> & {
  /**
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * @generated from field: int32 type = 2;
   */
  type: number;

  /**
   * @generated from field: string spread_factor = 3 [json_name = "spread_factor"];
   */
  spreadFactor: string;

  /**
   * @generated from field: string token_out_denom = 4 [json_name = "token_out_denom"];
   */
  tokenOutDenom: string;

  /**
   * @generated from field: string taker_fee = 5 [json_name = "taker_fee"];
   */
  takerFee: string;

  /**
   * @generated from field: string liquidity_cap = 6 [json_name = "liquidity_cap"];
   */
  liquidityCap: string;
};

/**
 * Describes the message pathfinder.v1.OsmosisPool.
 * Use `create(OsmosisPoolSchema)` to create a new message.
 */
export const OsmosisPoolSchema: GenMessage<OsmosisPool> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 11);

/**
 * LookupDenomRequest - Resolve token information
 * Accepts either:
 * - Human-readable denom (e.g., "uatone", "uosmo")
 * - IBC denom (e.g., "ibc/ABC123...")
 *
 * @generated from message pathfinder.v1.LookupDenomRequest
 */
export type LookupDenomRequest = Message<"pathfinder.v1.LookupDenomRequest"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: string denom = 2;
   */
  denom: string;
};

/**
 * Describes the message pathfinder.v1.LookupDenomRequest.
 * Use `create(LookupDenomRequestSchema)` to create a new message.
 */
export const LookupDenomRequestSchema: GenMessage<LookupDenomRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 12);

/**
 * @generated from message pathfinder.v1.LookupDenomResponse
 */
export type LookupDenomResponse = Message<"pathfinder.v1.LookupDenomResponse"> & {
  /**
   * @generated from field: bool found = 1;
   */
  found: boolean;

  /**
   * The denom as it appears on this chain
   *
   * @generated from field: string chain_denom = 2 [json_name = "chain_denom"];
   */
  chainDenom: string;

  /**
   * The base/native denom
   *
   * @generated from field: string base_denom = 3 [json_name = "base_denom"];
   */
  baseDenom: string;

  /**
   * Where this token is native
   *
   * @generated from field: string origin_chain = 4 [json_name = "origin_chain"];
   */
  originChain: string;

  /**
   * True if this is the token's native chain
   *
   * @generated from field: bool is_native = 5 [json_name = "is_native"];
   */
  isNative: boolean;

  /**
   * IBC path if this is an IBC token (e.g., "transfer/channel-75")
   *
   * @generated from field: string ibc_path = 6 [json_name = "ibc_path"];
   */
  ibcPath: string;

  /**
   * Denoms on other chains where this token is available
   *
   * @generated from field: repeated pathfinder.v1.ChainDenom available_on = 7 [json_name = "available_on"];
   */
  availableOn: ChainDenom[];
};

/**
 * Describes the message pathfinder.v1.LookupDenomResponse.
 * Use `create(LookupDenomResponseSchema)` to create a new message.
 */
export const LookupDenomResponseSchema: GenMessage<LookupDenomResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 13);

/**
 * ChainDenom represents a token's denom on a specific chain
 *
 * @generated from message pathfinder.v1.ChainDenom
 */
export type ChainDenom = Message<"pathfinder.v1.ChainDenom"> & {
  /**
   * @generated from field: string chain_id = 1 [json_name = "chain_id"];
   */
  chainId: string;

  /**
   * @generated from field: string chain_name = 2 [json_name = "chain_name"];
   */
  chainName: string;

  /**
   * @generated from field: string denom = 3;
   */
  denom: string;

  /**
   * @generated from field: bool is_native = 4 [json_name = "is_native"];
   */
  isNative: boolean;
};

/**
 * Describes the message pathfinder.v1.ChainDenom.
 * Use `create(ChainDenomSchema)` to create a new message.
 */
export const ChainDenomSchema: GenMessage<ChainDenom> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 14);

/**
 * GetTokenDenomsRequest - Get all denoms for a token across chains
 * Use this to discover what denom a token has on different chains
 *
 * @generated from message pathfinder.v1.GetTokenDenomsRequest
 */
export type GetTokenDenomsRequest = Message<"pathfinder.v1.GetTokenDenomsRequest"> & {
  /**
   * The base denom (e.g., "uatone", "uosmo", "ustars")
   *
   * @generated from field: string base_denom = 1;
   */
  baseDenom: string;

  /**
   * The chain where this token is native (e.g., "atomone-1", "osmosis-1")
   *
   * @generated from field: string origin_chain = 2;
   */
  originChain: string;

  /**
   * Optional: Filter to a specific chain. If empty, returns denoms on all chains
   *
   * @generated from field: string on_chain_id = 3;
   */
  onChainId: string;
};

/**
 * Describes the message pathfinder.v1.GetTokenDenomsRequest.
 * Use `create(GetTokenDenomsRequestSchema)` to create a new message.
 */
export const GetTokenDenomsRequestSchema: GenMessage<GetTokenDenomsRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 15);

/**
 * @generated from message pathfinder.v1.GetTokenDenomsResponse
 */
export type GetTokenDenomsResponse = Message<"pathfinder.v1.GetTokenDenomsResponse"> & {
  /**
   * @generated from field: bool found = 1;
   */
  found: boolean;

  /**
   * @generated from field: string base_denom = 2 [json_name = "base_denom"];
   */
  baseDenom: string;

  /**
   * @generated from field: string origin_chain = 3 [json_name = "origin_chain"];
   */
  originChain: string;

  /**
   * All chains where this token is available and what denom it has
   *
   * @generated from field: repeated pathfinder.v1.ChainDenom denoms = 4;
   */
  denoms: ChainDenom[];
};

/**
 * Describes the message pathfinder.v1.GetTokenDenomsResponse.
 * Use `create(GetTokenDenomsResponseSchema)` to create a new message.
 */
export const GetTokenDenomsResponseSchema: GenMessage<GetTokenDenomsResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 16);

/**
 * GetChainTokensRequest - Get all tokens on a chain
 *
 * @generated from message pathfinder.v1.GetChainTokensRequest
 */
export type GetChainTokensRequest = Message<"pathfinder.v1.GetChainTokensRequest"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;
};

/**
 * Describes the message pathfinder.v1.GetChainTokensRequest.
 * Use `create(GetChainTokensRequestSchema)` to create a new message.
 */
export const GetChainTokensRequestSchema: GenMessage<GetChainTokensRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 17);

/**
 * @generated from message pathfinder.v1.GetChainTokensResponse
 */
export type GetChainTokensResponse = Message<"pathfinder.v1.GetChainTokensResponse"> & {
  /**
   * @generated from field: string chain_id = 1 [json_name = "chain_id"];
   */
  chainId: string;

  /**
   * @generated from field: string chain_name = 2 [json_name = "chain_name"];
   */
  chainName: string;

  /**
   * Native tokens on this chain
   *
   * @generated from field: repeated pathfinder.v1.TokenDetails native_tokens = 3 [json_name = "native_tokens"];
   */
  nativeTokens: TokenDetails[];

  /**
   * IBC tokens received on this chain
   *
   * @generated from field: repeated pathfinder.v1.TokenDetails ibc_tokens = 4 [json_name = "ibc_tokens"];
   */
  ibcTokens: TokenDetails[];
};

/**
 * Describes the message pathfinder.v1.GetChainTokensResponse.
 * Use `create(GetChainTokensResponseSchema)` to create a new message.
 */
export const GetChainTokensResponseSchema: GenMessage<GetChainTokensResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 18);

/**
 * TokenDetails - Full token information
 *
 * @generated from message pathfinder.v1.TokenDetails
 */
export type TokenDetails = Message<"pathfinder.v1.TokenDetails"> & {
  /**
   * Denom on this chain (native or IBC hash)
   *
   * @generated from field: string denom = 1;
   */
  denom: string;

  /**
   * Human-readable symbol (e.g., "ATONE", "OSMO")
   *
   * @generated from field: string symbol = 2;
   */
  symbol: string;

  /**
   * Base denom on origin chain
   *
   * @generated from field: string base_denom = 3 [json_name = "base_denom"];
   */
  baseDenom: string;

  /**
   * Chain where token is native
   *
   * @generated from field: string origin_chain = 4 [json_name = "origin_chain"];
   */
  originChain: string;

  /**
   * Number of decimals
   *
   * @generated from field: int32 decimals = 5;
   */
  decimals: number;

  /**
   * True if native to this chain
   *
   * @generated from field: bool is_native = 6 [json_name = "is_native"];
   */
  isNative: boolean;
};

/**
 * Describes the message pathfinder.v1.TokenDetails.
 * Use `create(TokenDetailsSchema)` to create a new message.
 */
export const TokenDetailsSchema: GenMessage<TokenDetails> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 19);

/**
 * @generated from message pathfinder.v1.PathfinderSupportedChainsResponse
 */
export type PathfinderSupportedChainsResponse = Message<"pathfinder.v1.PathfinderSupportedChainsResponse"> & {
  /**
   * @generated from field: repeated string chain_ids = 1 [json_name = "chain_ids"];
   */
  chainIds: string[];
};

/**
 * Describes the message pathfinder.v1.PathfinderSupportedChainsResponse.
 * Use `create(PathfinderSupportedChainsResponseSchema)` to create a new message.
 */
export const PathfinderSupportedChainsResponseSchema: GenMessage<PathfinderSupportedChainsResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 20);

/**
 * @generated from message pathfinder.v1.ChainInfoRequest
 */
export type ChainInfoRequest = Message<"pathfinder.v1.ChainInfoRequest"> & {
  /**
   * The chain id of the chain to get information for
   *
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * Whether to show the symbols of the tokens on the chain, default is false
   *
   * @generated from field: bool show_symbols = 2;
   */
  showSymbols: boolean;
};

/**
 * Describes the message pathfinder.v1.ChainInfoRequest.
 * Use `create(ChainInfoRequestSchema)` to create a new message.
 */
export const ChainInfoRequestSchema: GenMessage<ChainInfoRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 21);

/**
 * @generated from message pathfinder.v1.ChainInfoResponse
 */
export type ChainInfoResponse = Message<"pathfinder.v1.ChainInfoResponse"> & {
  /**
   * @generated from field: pathfinder.v1.ChainInfo chain_info = 1 [json_name = "chain_info"];
   */
  chainInfo?: ChainInfo;
};

/**
 * Describes the message pathfinder.v1.ChainInfoResponse.
 * Use `create(ChainInfoResponseSchema)` to create a new message.
 */
export const ChainInfoResponseSchema: GenMessage<ChainInfoResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 22);

/**
 * @generated from message pathfinder.v1.ChainInfo
 */
export type ChainInfo = Message<"pathfinder.v1.ChainInfo"> & {
  /**
   * @generated from field: string chain_id = 1 [json_name = "chain_id"];
   */
  chainId: string;

  /**
   * @generated from field: string chain_name = 2 [json_name = "chain_name"];
   */
  chainName: string;

  /**
   * @generated from field: bool has_pfm = 3 [json_name = "has_pfm"];
   */
  hasPfm: boolean;

  /**
   * @generated from field: bool is_broker = 4 [json_name = "is_broker"];
   */
  isBroker: boolean;

  /**
   * @generated from field: repeated pathfinder.v1.BasicRoute routes = 5;
   */
  routes: BasicRoute[];
};

/**
 * Describes the message pathfinder.v1.ChainInfo.
 * Use `create(ChainInfoSchema)` to create a new message.
 */
export const ChainInfoSchema: GenMessage<ChainInfo> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 23);

/**
 * @generated from message pathfinder.v1.TokenInfo
 */
export type TokenInfo = Message<"pathfinder.v1.TokenInfo"> & {
  /**
   * @generated from field: string chain_denom = 1 [json_name = "chain_denom"];
   */
  chainDenom: string;

  /**
   * @generated from field: string ibc_denom = 2 [json_name = "ibc_denom"];
   */
  ibcDenom: string;

  /**
   * @generated from field: string base_denom = 3 [json_name = "base_denom"];
   */
  baseDenom: string;

  /**
   * @generated from field: string origin_chain = 4 [json_name = "origin_chain"];
   */
  originChain: string;

  /**
   * @generated from field: int32 decimals = 5;
   */
  decimals: number;

  /**
   * @generated from field: string symbol = 6;
   */
  symbol: string;
};

/**
 * Describes the message pathfinder.v1.TokenInfo.
 * Use `create(TokenInfoSchema)` to create a new message.
 */
export const TokenInfoSchema: GenMessage<TokenInfo> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 24);

/**
 * @generated from message pathfinder.v1.BasicRoute
 */
export type BasicRoute = Message<"pathfinder.v1.BasicRoute"> & {
  /**
   * @generated from field: string to_chain = 1 [json_name = "to_chain"];
   */
  toChain: string;

  /**
   * @generated from field: string to_chain_id = 2 [json_name = "to_chain_id"];
   */
  toChainId: string;

  /**
   * @generated from field: string connection_id = 3 [json_name = "connection_id"];
   */
  connectionId: string;

  /**
   * @generated from field: string channel_id = 4 [json_name = "channel_id"];
   */
  channelId: string;

  /**
   * @generated from field: string port_id = 5 [json_name = "port_id"];
   */
  portId: string;

  /**
   * @generated from field: map<string, pathfinder.v1.TokenInfo> allowed_tokens = 6 [json_name = "allowed_tokens"];
   */
  allowedTokens: { [key: string]: TokenInfo };
};

/**
 * Describes the message pathfinder.v1.BasicRoute.
 * Use `create(BasicRouteSchema)` to create a new message.
 */
export const BasicRouteSchema: GenMessage<BasicRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 25);

/**
 * @generated from message pathfinder.v1.WasmData
 */
export type WasmData = Message<"pathfinder.v1.WasmData"> & {
  /**
   * @generated from field: string contract = 1;
   */
  contract: string;

  /**
   * @generated from field: pathfinder.v1.WasmMsg msg = 2;
   */
  msg?: WasmMsg;
};

/**
 * Describes the message pathfinder.v1.WasmData.
 * Use `create(WasmDataSchema)` to create a new message.
 */
export const WasmDataSchema: GenMessage<WasmData> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 26);

/**
 * @generated from message pathfinder.v1.WasmMsg
 */
export type WasmMsg = Message<"pathfinder.v1.WasmMsg"> & {
  /**
   * @generated from field: pathfinder.v1.SwapAndAction swap_and_action = 1 [json_name = "swap_and_action"];
   */
  swapAndAction?: SwapAndAction;
};

/**
 * Describes the message pathfinder.v1.WasmMsg.
 * Use `create(WasmMsgSchema)` to create a new message.
 */
export const WasmMsgSchema: GenMessage<WasmMsg> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 27);

/**
 * @generated from message pathfinder.v1.SwapAndAction
 */
export type SwapAndAction = Message<"pathfinder.v1.SwapAndAction"> & {
  /**
   * SwapAndAction is the entry point contract message structure
   *
   * @generated from field: pathfinder.v1.UserSwap user_swap = 1 [json_name = "user_swap"];
   */
  userSwap?: UserSwap;

  /**
   * @generated from field: pathfinder.v1.MinAsset min_asset = 2 [json_name = "min_asset"];
   */
  minAsset?: MinAsset;

  /**
   * @generated from field: int64 timeout_timestamp = 3 [json_name = "timeout_timestamp"];
   */
  timeoutTimestamp: bigint;

  /**
   * @generated from field: pathfinder.v1.PostSwapAction post_swap_action = 4 [json_name = "post_swap_action"];
   */
  postSwapAction?: PostSwapAction;

  /**
   * @generated from field: repeated string affiliates = 5;
   */
  affiliates: string[];
};

/**
 * Describes the message pathfinder.v1.SwapAndAction.
 * Use `create(SwapAndActionSchema)` to create a new message.
 */
export const SwapAndActionSchema: GenMessage<SwapAndAction> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 28);

/**
 * @generated from message pathfinder.v1.SwapExactAssetIn
 */
export type SwapExactAssetIn = Message<"pathfinder.v1.SwapExactAssetIn"> & {
  /**
   * @generated from field: string swap_venue_name = 1 [json_name = "swap_venue_name"];
   */
  swapVenueName: string;

  /**
   * @generated from field: repeated pathfinder.v1.SwapOperation operations = 2;
   */
  operations: SwapOperation[];
};

/**
 * Describes the message pathfinder.v1.SwapExactAssetIn.
 * Use `create(SwapExactAssetInSchema)` to create a new message.
 */
export const SwapExactAssetInSchema: GenMessage<SwapExactAssetIn> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 29);

/**
 * @generated from message pathfinder.v1.SwapOperation
 */
export type SwapOperation = Message<"pathfinder.v1.SwapOperation"> & {
  /**
   * @generated from field: string pool = 1;
   */
  pool: string;

  /**
   * @generated from field: string denom_in = 2 [json_name = "denom_in"];
   */
  denomIn: string;

  /**
   * @generated from field: string denom_out = 3 [json_name = "denom_out"];
   */
  denomOut: string;

  /**
   * Interface is used by some DEXs (like Injective), optional
   *
   * @generated from field: optional string interface = 4;
   */
  interface?: string;
};

/**
 * Describes the message pathfinder.v1.SwapOperation.
 * Use `create(SwapOperationSchema)` to create a new message.
 */
export const SwapOperationSchema: GenMessage<SwapOperation> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 30);

/**
 * @generated from message pathfinder.v1.MinAsset
 */
export type MinAsset = Message<"pathfinder.v1.MinAsset"> & {
  /**
   * @generated from field: pathfinder.v1.Asset native = 1;
   */
  native?: Asset;
};

/**
 * Describes the message pathfinder.v1.MinAsset.
 * Use `create(MinAssetSchema)` to create a new message.
 */
export const MinAssetSchema: GenMessage<MinAsset> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 31);

/**
 * @generated from message pathfinder.v1.Asset
 */
export type Asset = Message<"pathfinder.v1.Asset"> & {
  /**
   * @generated from field: string amount = 1;
   */
  amount: string;

  /**
   * @generated from field: string denom = 2;
   */
  denom: string;
};

/**
 * Describes the message pathfinder.v1.Asset.
 * Use `create(AssetSchema)` to create a new message.
 */
export const AssetSchema: GenMessage<Asset> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 32);

/**
 * @generated from message pathfinder.v1.PostSwapAction
 */
export type PostSwapAction = Message<"pathfinder.v1.PostSwapAction"> & {
  /**
   * @generated from oneof pathfinder.v1.PostSwapAction.action
   */
  action: {
    /**
     * @generated from field: pathfinder.v1.IBCTransfer ibc_transfer = 1 [json_name = "ibc_transfer"];
     */
    value: IBCTransfer;
    case: "ibcTransfer";
  } | {
    /**
     * @generated from field: pathfinder.v1.Transfer transfer = 2;
     */
    value: Transfer;
    case: "transfer";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message pathfinder.v1.PostSwapAction.
 * Use `create(PostSwapActionSchema)` to create a new message.
 */
export const PostSwapActionSchema: GenMessage<PostSwapAction> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 33);

/**
 * @generated from message pathfinder.v1.IBCTransfer
 */
export type IBCTransfer = Message<"pathfinder.v1.IBCTransfer"> & {
  /**
   * @generated from field: pathfinder.v1.IBCInfo ibc_info = 1 [json_name = "ibc_info"];
   */
  ibcInfo?: IBCInfo;
};

/**
 * Describes the message pathfinder.v1.IBCTransfer.
 * Use `create(IBCTransferSchema)` to create a new message.
 */
export const IBCTransferSchema: GenMessage<IBCTransfer> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 34);

/**
 * @generated from message pathfinder.v1.Transfer
 */
export type Transfer = Message<"pathfinder.v1.Transfer"> & {
  /**
   * @generated from field: string to_address = 1 [json_name = "to_address"];
   */
  toAddress: string;
};

/**
 * Describes the message pathfinder.v1.Transfer.
 * Use `create(TransferSchema)` to create a new message.
 */
export const TransferSchema: GenMessage<Transfer> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 35);

/**
 * @generated from message pathfinder.v1.IBCInfo
 */
export type IBCInfo = Message<"pathfinder.v1.IBCInfo"> & {
  /**
   * @generated from field: string memo = 1;
   */
  memo: string;

  /**
   * @generated from field: string receiver = 2;
   */
  receiver: string;

  /**
   * @generated from field: string recover_address = 3 [json_name = "recover_address"];
   */
  recoverAddress: string;

  /**
   * @generated from field: string source_channel = 4 [json_name = "source_channel"];
   */
  sourceChannel: string;
};

/**
 * Describes the message pathfinder.v1.IBCInfo.
 * Use `create(IBCInfoSchema)` to create a new message.
 */
export const IBCInfoSchema: GenMessage<IBCInfo> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 36);

/**
 * @generated from message pathfinder.v1.UserSwap
 */
export type UserSwap = Message<"pathfinder.v1.UserSwap"> & {
  /**
   * @generated from field: pathfinder.v1.SwapExactAssetIn swap_exact_asset_in = 1 [json_name = "swap_exact_asset_in"];
   */
  swapExactAssetIn?: SwapExactAssetIn;
};

/**
 * Describes the message pathfinder.v1.UserSwap.
 * Use `create(UserSwapSchema)` to create a new message.
 */
export const UserSwapSchema: GenMessage<UserSwap> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 37);

/**
 * PathfinderService provides route discovery and validation for IBC transfers and swaps
 *
 * @generated from service pathfinder.v1.PathfinderService
 */
export const PathfinderService: GenService<{
  /**
   * FindPath finds and validates a route between two chains
   * Supports human-readable denoms (e.g., "uatone") or IBC denoms
   *
   * @generated from rpc pathfinder.v1.PathfinderService.FindPath
   */
  findPath: {
    methodKind: "unary";
    input: typeof FindPathRequestSchema;
    output: typeof FindPathResponseSchema;
  },
  /**
   * LookupDenom resolves denom information on a specific chain
   * Accepts human-readable base denoms or IBC denom hashes
   *
   * @generated from rpc pathfinder.v1.PathfinderService.LookupDenom
   */
  lookupDenom: {
    methodKind: "unary";
    input: typeof LookupDenomRequestSchema;
    output: typeof LookupDenomResponseSchema;
  },
  /**
   * GetTokenDenoms returns all IBC denoms for a token across supported chains
   * Use this to discover what denom a token has on different chains
   *
   * @generated from rpc pathfinder.v1.PathfinderService.GetTokenDenoms
   */
  getTokenDenoms: {
    methodKind: "unary";
    input: typeof GetTokenDenomsRequestSchema;
    output: typeof GetTokenDenomsResponseSchema;
  },
  /**
   * GetChainInfo returns information about a specific chain
   *
   * @generated from rpc pathfinder.v1.PathfinderService.GetChainInfo
   */
  getChainInfo: {
    methodKind: "unary";
    input: typeof ChainInfoRequestSchema;
    output: typeof ChainInfoResponseSchema;
  },
  /**
   * ListSupportedChains returns a list of supported chains
   *
   * @generated from rpc pathfinder.v1.PathfinderService.ListSupportedChains
   */
  listSupportedChains: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof PathfinderSupportedChainsResponseSchema;
  },
  /**
   * GetChainTokens returns all tokens available on a specific chain
   * Includes both native tokens and IBC tokens with their denoms
   *
   * @generated from rpc pathfinder.v1.PathfinderService.GetChainTokens
   */
  getChainTokens: {
    methodKind: "unary";
    input: typeof GetChainTokensRequestSchema;
    output: typeof GetChainTokensResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_pathfinder_route, 0);

