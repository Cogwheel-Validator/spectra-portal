// @generated by protoc-gen-es v2.10.2 with parameter "target=ts"
// @generated from file pathfinder_route.proto (package pathfinder.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_buf_validate_validate } from "./buf/validate/validate_pb";
import type { EmptySchema } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file pathfinder_route.proto.
 */
export const file_pathfinder_route: GenFile = /*@__PURE__*/
  fileDesc("ChZwYXRoZmluZGVyX3JvdXRlLnByb3RvEg1wYXRoZmluZGVyLnYxIrYCCg9GaW5kUGF0aFJlcXVlc3QSGgoKY2hhaW5fZnJvbRgBIAEoCUIGukgDyAEBEicKEHRva2VuX2Zyb21fZGVub20YAiABKAlCDbpICsgBAXIFEAEYgAESGQoJYW1vdW50X2luGAMgASgJQga6SAPIAQESGAoIY2hhaW5fdG8YBCABKAlCBrpIA8gBARIgCg50b2tlbl90b19kZW5vbRgFIAEoCUIIukgFcgMYgAESJAoOc2VuZGVyX2FkZHJlc3MYBiABKAlCDLpICcgBAXIEECYYRBImChByZWNlaXZlcl9hZGRyZXNzGAcgASgJQgy6SAnIAQFyBBAmGEQSFAoMc2luZ2xlX3JvdXRlGAggASgIEiMKDHNsaXBwYWdlX2JwcxgJIAEoDUINukgKyAEAKgUYkE4oACLaAQoQRmluZFBhdGhSZXNwb25zZRIPCgdzdWNjZXNzGAEgASgIEhUKDWVycm9yX21lc3NhZ2UYAiABKAkSLAoGZGlyZWN0GAMgASgLMhoucGF0aGZpbmRlci52MS5EaXJlY3RSb3V0ZUgAEjAKCGluZGlyZWN0GAQgASgLMhwucGF0aGZpbmRlci52MS5JbmRpcmVjdFJvdXRlSAASNQoLYnJva2VyX3N3YXAYBSABKAsyHi5wYXRoZmluZGVyLnYxLkJyb2tlclN3YXBSb3V0ZUgAQgcKBXJvdXRlIjYKC0RpcmVjdFJvdXRlEicKCHRyYW5zZmVyGAEgASgLMhUucGF0aGZpbmRlci52MS5JQkNMZWcigwEKDUluZGlyZWN0Um91dGUSDAoEcGF0aBgBIAMoCRIjCgRsZWdzGAIgAygLMhUucGF0aGZpbmRlci52MS5JQkNMZWcSFAoMc3VwcG9ydHNfcGZtGAMgASgIEhcKD3BmbV9zdGFydF9jaGFpbhgEIAEoCRIQCghwZm1fbWVtbxgFIAEoCSL4AQoPQnJva2VyU3dhcFJvdXRlEgwKBHBhdGgYASADKAkSKwoMaW5ib3VuZF9sZWdzGAIgAygLMhUucGF0aGZpbmRlci52MS5JQkNMZWcSJgoEc3dhcBgDIAEoCzIYLnBhdGhmaW5kZXIudjEuU3dhcFF1b3RlEiwKDW91dGJvdW5kX2xlZ3MYBCADKAsyFS5wYXRoZmluZGVyLnYxLklCQ0xlZxIdChVvdXRib3VuZF9zdXBwb3J0c19wZm0YBSABKAgSNQoJZXhlY3V0aW9uGAYgASgLMiIucGF0aGZpbmRlci52MS5Ccm9rZXJFeGVjdXRpb25EYXRhIpUBChNCcm9rZXJFeGVjdXRpb25EYXRhEgwKBG1lbW8YASABKAkSFAoMaWJjX3JlY2VpdmVyGAIgASgJEhcKD3JlY292ZXJfYWRkcmVzcxgDIAEoCRIZChFtaW5fb3V0cHV0X2Ftb3VudBgEIAEoCRIRCgl1c2VzX3dhc20YBSABKAgSEwoLZGVzY3JpcHRpb24YBiABKAkiiQEKBklCQ0xlZxISCgpmcm9tX2NoYWluGAEgASgJEhAKCHRvX2NoYWluGAIgASgJEg8KB2NoYW5uZWwYAyABKAkSDAoEcG9ydBgEIAEoCRIqCgV0b2tlbhgFIAEoCzIbLnBhdGhmaW5kZXIudjEuVG9rZW5NYXBwaW5nEg4KBmFtb3VudBgGIAEoCSJgCgxUb2tlbk1hcHBpbmcSEwoLY2hhaW5fZGVub20YASABKAkSEgoKYmFzZV9kZW5vbRgCIAEoCRIUCgxvcmlnaW5fY2hhaW4YAyABKAkSEQoJaXNfbmF0aXZlGAQgASgIIpsCCglTd2FwUXVvdGUSDgoGYnJva2VyGAEgASgJEi0KCHRva2VuX2luGAIgASgLMhsucGF0aGZpbmRlci52MS5Ub2tlbk1hcHBpbmcSLgoJdG9rZW5fb3V0GAMgASgLMhsucGF0aGZpbmRlci52MS5Ub2tlbk1hcHBpbmcSEQoJYW1vdW50X2luGAQgASgJEhIKCmFtb3VudF9vdXQYBSABKAkSFAoMcHJpY2VfaW1wYWN0GAYgASgJEhUKDWVmZmVjdGl2ZV9mZWUYByABKAkSPQoSb3Ntb3Npc19yb3V0ZV9kYXRhGAggASgLMh8ucGF0aGZpbmRlci52MS5Pc21vc2lzUm91dGVEYXRhSABCDAoKcm91dGVfZGF0YSJ2ChBPc21vc2lzUm91dGVEYXRhEisKBnJvdXRlcxgBIAMoCzIbLnBhdGhmaW5kZXIudjEuT3Ntb3Npc1JvdXRlEhUKDWxpcXVpZGl0eV9jYXAYAiABKAkSHgoWbGlxdWlkaXR5X2NhcF9vdmVyZmxvdxgDIAEoCCJ1CgxPc21vc2lzUm91dGUSKQoFcG9vbHMYASADKAsyGi5wYXRoZmluZGVyLnYxLk9zbW9zaXNQb29sEhMKC2hhc19jd19wb29sGAIgASgIEhIKCm91dF9hbW91bnQYAyABKAkSEQoJaW5fYW1vdW50GAQgASgJIoEBCgtPc21vc2lzUG9vbBIKCgJpZBgBIAEoBRIMCgR0eXBlGAIgASgFEhUKDXNwcmVhZF9mYWN0b3IYAyABKAkSFwoPdG9rZW5fb3V0X2Rlbm9tGAQgASgJEhEKCXRha2VyX2ZlZRgFIAEoCRIVCg1saXF1aWRpdHlfY2FwGAYgASgJIkwKEkxvb2t1cERlbm9tUmVxdWVzdBIYCghjaGFpbl9pZBgBIAEoCUIGukgDyAEBEhwKBWRlbm9tGAIgASgJQg26SArIAQFyBRABGIABIrkBChNMb29rdXBEZW5vbVJlc3BvbnNlEg0KBWZvdW5kGAEgASgIEhMKC2NoYWluX2Rlbm9tGAIgASgJEhIKCmJhc2VfZGVub20YAyABKAkSFAoMb3JpZ2luX2NoYWluGAQgASgJEhEKCWlzX25hdGl2ZRgFIAEoCBIQCghpYmNfcGF0aBgGIAEoCRIvCgxhdmFpbGFibGVfb24YByADKAsyGS5wYXRoZmluZGVyLnYxLkNoYWluRGVub20iVAoKQ2hhaW5EZW5vbRIQCghjaGFpbl9pZBgBIAEoCRISCgpjaGFpbl9uYW1lGAIgASgJEg0KBWRlbm9tGAMgASgJEhEKCWlzX25hdGl2ZRgEIAEoCCJmChVHZXRUb2tlbkRlbm9tc1JlcXVlc3QSGgoKYmFzZV9kZW5vbRgBIAEoCUIGukgDyAEBEhwKDG9yaWdpbl9jaGFpbhgCIAEoCUIGukgDyAEBEhMKC29uX2NoYWluX2lkGAMgASgJInwKFkdldFRva2VuRGVub21zUmVzcG9uc2USDQoFZm91bmQYASABKAgSEgoKYmFzZV9kZW5vbRgCIAEoCRIUCgxvcmlnaW5fY2hhaW4YAyABKAkSKQoGZGVub21zGAQgAygLMhkucGF0aGZpbmRlci52MS5DaGFpbkRlbm9tIjEKFUdldENoYWluVG9rZW5zUmVxdWVzdBIYCghjaGFpbl9pZBgBIAEoCUIGukgDyAEBIqMBChZHZXRDaGFpblRva2Vuc1Jlc3BvbnNlEhAKCGNoYWluX2lkGAEgASgJEhIKCmNoYWluX25hbWUYAiABKAkSMgoNbmF0aXZlX3Rva2VucxgDIAMoCzIbLnBhdGhmaW5kZXIudjEuVG9rZW5EZXRhaWxzEi8KCmliY190b2tlbnMYBCADKAsyGy5wYXRoZmluZGVyLnYxLlRva2VuRGV0YWlscyJ8CgxUb2tlbkRldGFpbHMSDQoFZGVub20YASABKAkSDgoGc3ltYm9sGAIgASgJEhIKCmJhc2VfZGVub20YAyABKAkSFAoMb3JpZ2luX2NoYWluGAQgASgJEhAKCGRlY2ltYWxzGAUgASgFEhEKCWlzX25hdGl2ZRgGIAEoCCI+CiFQYXRoZmluZGVyU3VwcG9ydGVkQ2hhaW5zUmVzcG9uc2USGQoJY2hhaW5faWRzGAEgAygJQga6SAPIAQEiQgoQQ2hhaW5JbmZvUmVxdWVzdBIYCghjaGFpbl9pZBgBIAEoCUIGukgDyAEBEhQKDHNob3dfc3ltYm9scxgCIAEoCCJBChFDaGFpbkluZm9SZXNwb25zZRIsCgpjaGFpbl9pbmZvGAEgASgLMhgucGF0aGZpbmRlci52MS5DaGFpbkluZm8igAEKCUNoYWluSW5mbxIQCghjaGFpbl9pZBgBIAEoCRISCgpjaGFpbl9uYW1lGAIgASgJEg8KB2hhc19wZm0YAyABKAgSEQoJaXNfYnJva2VyGAQgASgIEikKBnJvdXRlcxgFIAMoCzIZLnBhdGhmaW5kZXIudjEuQmFzaWNSb3V0ZSJ/CglUb2tlbkluZm8SEwoLY2hhaW5fZGVub20YASABKAkSEQoJaWJjX2Rlbm9tGAIgASgJEhIKCmJhc2VfZGVub20YAyABKAkSFAoMb3JpZ2luX2NoYWluGAQgASgJEhAKCGRlY2ltYWxzGAUgASgFEg4KBnN5bWJvbBgGIAEoCSKFAgoKQmFzaWNSb3V0ZRIQCgh0b19jaGFpbhgBIAEoCRITCgt0b19jaGFpbl9pZBgCIAEoCRIVCg1jb25uZWN0aW9uX2lkGAMgASgJEhIKCmNoYW5uZWxfaWQYBCABKAkSDwoHcG9ydF9pZBgFIAEoCRJECg5hbGxvd2VkX3Rva2VucxgGIAMoCzIsLnBhdGhmaW5kZXIudjEuQmFzaWNSb3V0ZS5BbGxvd2VkVG9rZW5zRW50cnkaTgoSQWxsb3dlZFRva2Vuc0VudHJ5EgsKA2tleRgBIAEoCRInCgV2YWx1ZRgCIAEoCzIYLnBhdGhmaW5kZXIudjEuVG9rZW5JbmZvOgI4ATLGBAoRUGF0aGZpbmRlclNlcnZpY2USUAoIRmluZFBhdGgSHi5wYXRoZmluZGVyLnYxLkZpbmRQYXRoUmVxdWVzdBofLnBhdGhmaW5kZXIudjEuRmluZFBhdGhSZXNwb25zZSIDkAIBElkKC0xvb2t1cERlbm9tEiEucGF0aGZpbmRlci52MS5Mb29rdXBEZW5vbVJlcXVlc3QaIi5wYXRoZmluZGVyLnYxLkxvb2t1cERlbm9tUmVzcG9uc2UiA5ACARJiCg5HZXRUb2tlbkRlbm9tcxIkLnBhdGhmaW5kZXIudjEuR2V0VG9rZW5EZW5vbXNSZXF1ZXN0GiUucGF0aGZpbmRlci52MS5HZXRUb2tlbkRlbm9tc1Jlc3BvbnNlIgOQAgESVgoMR2V0Q2hhaW5JbmZvEh8ucGF0aGZpbmRlci52MS5DaGFpbkluZm9SZXF1ZXN0GiAucGF0aGZpbmRlci52MS5DaGFpbkluZm9SZXNwb25zZSIDkAIBEmQKE0xpc3RTdXBwb3J0ZWRDaGFpbnMSFi5nb29nbGUucHJvdG9idWYuRW1wdHkaMC5wYXRoZmluZGVyLnYxLlBhdGhmaW5kZXJTdXBwb3J0ZWRDaGFpbnNSZXNwb25zZSIDkAIBEmIKDkdldENoYWluVG9rZW5zEiQucGF0aGZpbmRlci52MS5HZXRDaGFpblRva2Vuc1JlcXVlc3QaJS5wYXRoZmluZGVyLnYxLkdldENoYWluVG9rZW5zUmVzcG9uc2UiA5ACAUJBWj9naXRodWIuY29tL0NvZ3doZWVsLVZhbGlkYXRvci9zcGVjdHJhLWliYy1odWIvcGF0aGZpbmRlci9ycGMvdjFiBnByb3RvMw", [file_buf_validate_validate, file_google_protobuf_empty]);

/**
 * FindPathRequest - Find a route between chains
 *
 * For token_from_denom and token_to_denom, you can use:
 * - Human-readable denom (e.g., "uatone", "uosmo", "ustars")
 * - Full IBC denom (e.g., "ibc/ABC123...")
 *
 * The pathfinder will automatically resolve human-readable denoms.
 * If token_to_denom is empty, the pathfinder assumes you want the same token
 * on the destination chain (useful for bridging without swapping).
 *
 * @generated from message pathfinder.v1.FindPathRequest
 */
export type FindPathRequest = Message<"pathfinder.v1.FindPathRequest"> & {
  /**
   * Source chain ID (e.g., "osmosis-1", "atomone-1")
   *
   * @generated from field: string chain_from = 1;
   */
  chainFrom: string;

  /**
   * Token denom on source chain - can be human-readable (e.g., "uatone") 
   * or IBC denom (e.g., "ibc/...")
   *
   * @generated from field: string token_from_denom = 2;
   */
  tokenFromDenom: string;

  /**
   * Amount to transfer/swap (in base units)
   *
   * @generated from field: string amount_in = 3;
   */
  amountIn: string;

  /**
   * Destination chain ID
   *
   * @generated from field: string chain_to = 4;
   */
  chainTo: string;

  /**
   * Token denom you want to receive on destination chain
   * Can be human-readable (e.g., "uosmo") or IBC denom
   * If empty, assumes same token as token_from (bridging without swap)
   *
   * @generated from field: string token_to_denom = 5;
   */
  tokenToDenom: string;

  /**
   * Sender address on source chain
   *
   * @generated from field: string sender_address = 6;
   */
  senderAddress: string;

  /**
   * Receiver address on destination chain
   *
   * @generated from field: string receiver_address = 7;
   */
  receiverAddress: string;

  /**
   * If true, only return a single route, if false, return all possible routes
   *
   * @generated from field: bool single_route = 8;
   */
  singleRoute: boolean;

  /**
   * Slippage in basis points (e.g., 100 = 1%, 1000 = 10%)
   * Must be less than 10000
   *
   * @generated from field: uint32 slippage_bps = 9;
   */
  slippageBps: number;
};

/**
 * Describes the message pathfinder.v1.FindPathRequest.
 * Use `create(FindPathRequestSchema)` to create a new message.
 */
export const FindPathRequestSchema: GenMessage<FindPathRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 0);

/**
 * @generated from message pathfinder.v1.FindPathResponse
 */
export type FindPathResponse = Message<"pathfinder.v1.FindPathResponse"> & {
  /**
   * @generated from field: bool success = 1;
   */
  success: boolean;

  /**
   * @generated from field: string error_message = 2;
   */
  errorMessage: string;

  /**
   * @generated from oneof pathfinder.v1.FindPathResponse.route
   */
  route: {
    /**
     * @generated from field: pathfinder.v1.DirectRoute direct = 3;
     */
    value: DirectRoute;
    case: "direct";
  } | {
    /**
     * @generated from field: pathfinder.v1.IndirectRoute indirect = 4;
     */
    value: IndirectRoute;
    case: "indirect";
  } | {
    /**
     * @generated from field: pathfinder.v1.BrokerSwapRoute broker_swap = 5;
     */
    value: BrokerSwapRoute;
    case: "brokerSwap";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message pathfinder.v1.FindPathResponse.
 * Use `create(FindPathResponseSchema)` to create a new message.
 */
export const FindPathResponseSchema: GenMessage<FindPathResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 1);

/**
 * @generated from message pathfinder.v1.DirectRoute
 */
export type DirectRoute = Message<"pathfinder.v1.DirectRoute"> & {
  /**
   * @generated from field: pathfinder.v1.IBCLeg transfer = 1;
   */
  transfer?: IBCLeg;
};

/**
 * Describes the message pathfinder.v1.DirectRoute.
 * Use `create(DirectRouteSchema)` to create a new message.
 */
export const DirectRouteSchema: GenMessage<DirectRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 2);

/**
 * @generated from message pathfinder.v1.IndirectRoute
 */
export type IndirectRoute = Message<"pathfinder.v1.IndirectRoute"> & {
  /**
   * @generated from field: repeated string path = 1;
   */
  path: string[];

  /**
   * @generated from field: repeated pathfinder.v1.IBCLeg legs = 2;
   */
  legs: IBCLeg[];

  /**
   * @generated from field: bool supports_pfm = 3;
   */
  supportsPfm: boolean;

  /**
   * @generated from field: string pfm_start_chain = 4;
   */
  pfmStartChain: string;

  /**
   * @generated from field: string pfm_memo = 5;
   */
  pfmMemo: string;
};

/**
 * Describes the message pathfinder.v1.IndirectRoute.
 * Use `create(IndirectRouteSchema)` to create a new message.
 */
export const IndirectRouteSchema: GenMessage<IndirectRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 3);

/**
 * BrokerSwapRoute represents a route involving a swap on a broker chain.
 * Supports various scenarios:
 * - Same-chain swap: inbound_leg absent, outbound_legs=[] (e.g., osmosis ATOM -> osmosis OSMO)
 * - Swap from broker: inbound_leg absent (e.g., osmosis USDC -> juno JUNO)
 * - Standard 3-chain: inbound_leg set, len(outbound_legs)=1
 * - Multi-hop outbound: inbound_leg set, len(outbound_legs)>1 (e.g., cosmos ATOM -> swap -> noble -> juno)
 *
 * @generated from message pathfinder.v1.BrokerSwapRoute
 */
export type BrokerSwapRoute = Message<"pathfinder.v1.BrokerSwapRoute"> & {
  /**
   * All chain IDs in order
   *
   * @generated from field: repeated string path = 1;
   */
  path: string[];

  /**
   * IBC transfer to reach broker (absent if starting from broker)
   *
   * @generated from field: repeated pathfinder.v1.IBCLeg inbound_legs = 2;
   */
  inboundLegs: IBCLeg[];

  /**
   * The swap operation on the broker chain
   *
   * @generated from field: pathfinder.v1.SwapQuote swap = 3;
   */
  swap?: SwapQuote;

  /**
   * IBC transfers after swap (empty if destination is broker)
   * Can be multiple for multi-hop forwarding via PFM
   *
   * @generated from field: repeated pathfinder.v1.IBCLeg outbound_legs = 4;
   */
  outboundLegs: IBCLeg[];

  /**
   * Can use PFM for outbound legs
   *
   * @generated from field: bool outbound_supports_pfm = 5;
   */
  outboundSupportsPfm: boolean;

  /**
   * Execution data for building transactions
   *
   * @generated from field: pathfinder.v1.BrokerExecutionData execution = 6;
   */
  execution?: BrokerExecutionData;
};

/**
 * Describes the message pathfinder.v1.BrokerSwapRoute.
 * Use `create(BrokerSwapRouteSchema)` to create a new message.
 */
export const BrokerSwapRouteSchema: GenMessage<BrokerSwapRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 4);

/**
 * BrokerExecutionData contains ready-to-use transaction data
 *
 * @generated from message pathfinder.v1.BrokerExecutionData
 */
export type BrokerExecutionData = Message<"pathfinder.v1.BrokerExecutionData"> & {
  /**
   * The IBC memo to use with MsgTransfer (contains wasm swap_and_action)
   *
   * @generated from field: string memo = 1;
   */
  memo: string;

  /**
   * Receiver address for MsgTransfer (the ibc-hooks contract)
   *
   * @generated from field: string ibc_receiver = 2;
   */
  ibcReceiver: string;

  /**
   * Recovery address on broker chain (where funds go if swap/forward fails)
   *
   * @generated from field: string recover_address = 3;
   */
  recoverAddress: string;

  /**
   * Minimum output amount after slippage (1% default)
   *
   * @generated from field: string min_output_amount = 4;
   */
  minOutputAmount: string;

  /**
   * True if using wasm ibc-hooks (vs simple PFM)
   *
   * @generated from field: bool uses_wasm = 5;
   */
  usesWasm: boolean;

  /**
   * Human-readable description
   *
   * @generated from field: string description = 6;
   */
  description: string;
};

/**
 * Describes the message pathfinder.v1.BrokerExecutionData.
 * Use `create(BrokerExecutionDataSchema)` to create a new message.
 */
export const BrokerExecutionDataSchema: GenMessage<BrokerExecutionData> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 5);

/**
 * @generated from message pathfinder.v1.IBCLeg
 */
export type IBCLeg = Message<"pathfinder.v1.IBCLeg"> & {
  /**
   * @generated from field: string from_chain = 1;
   */
  fromChain: string;

  /**
   * @generated from field: string to_chain = 2;
   */
  toChain: string;

  /**
   * @generated from field: string channel = 3;
   */
  channel: string;

  /**
   * @generated from field: string port = 4;
   */
  port: string;

  /**
   * @generated from field: pathfinder.v1.TokenMapping token = 5;
   */
  token?: TokenMapping;

  /**
   * @generated from field: string amount = 6;
   */
  amount: string;
};

/**
 * Describes the message pathfinder.v1.IBCLeg.
 * Use `create(IBCLegSchema)` to create a new message.
 */
export const IBCLegSchema: GenMessage<IBCLeg> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 6);

/**
 * @generated from message pathfinder.v1.TokenMapping
 */
export type TokenMapping = Message<"pathfinder.v1.TokenMapping"> & {
  /**
   * The denom as it appears on the current chain (native or IBC)
   *
   * @generated from field: string chain_denom = 1;
   */
  chainDenom: string;

  /**
   * The base/native denom on the token's origin chain
   *
   * @generated from field: string base_denom = 2;
   */
  baseDenom: string;

  /**
   * The chain ID where this token is native
   *
   * @generated from field: string origin_chain = 3;
   */
  originChain: string;

  /**
   * True if this is the token's native chain
   *
   * @generated from field: bool is_native = 4;
   */
  isNative: boolean;
};

/**
 * Describes the message pathfinder.v1.TokenMapping.
 * Use `create(TokenMappingSchema)` to create a new message.
 */
export const TokenMappingSchema: GenMessage<TokenMapping> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 7);

/**
 * SwapQuote with broker-specific route data
 *
 * @generated from message pathfinder.v1.SwapQuote
 */
export type SwapQuote = Message<"pathfinder.v1.SwapQuote"> & {
  /**
   * @generated from field: string broker = 1;
   */
  broker: string;

  /**
   * @generated from field: pathfinder.v1.TokenMapping token_in = 2;
   */
  tokenIn?: TokenMapping;

  /**
   * @generated from field: pathfinder.v1.TokenMapping token_out = 3;
   */
  tokenOut?: TokenMapping;

  /**
   * @generated from field: string amount_in = 4;
   */
  amountIn: string;

  /**
   * @generated from field: string amount_out = 5;
   */
  amountOut: string;

  /**
   * @generated from field: string price_impact = 6;
   */
  priceImpact: string;

  /**
   * @generated from field: string effective_fee = 7;
   */
  effectiveFee: string;

  /**
   * Broker-specific route data using oneof for type safety
   *
   * @generated from oneof pathfinder.v1.SwapQuote.route_data
   */
  routeData: {
    /**
     * Future brokers can be added here without breaking existing clients
     *
     * @generated from field: pathfinder.v1.OsmosisRouteData osmosis_route_data = 8;
     */
    value: OsmosisRouteData;
    case: "osmosisRouteData";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message pathfinder.v1.SwapQuote.
 * Use `create(SwapQuoteSchema)` to create a new message.
 */
export const SwapQuoteSchema: GenMessage<SwapQuote> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 8);

/**
 * Osmosis-specific route data (from SQS API)
 *
 * @generated from message pathfinder.v1.OsmosisRouteData
 */
export type OsmosisRouteData = Message<"pathfinder.v1.OsmosisRouteData"> & {
  /**
   * @generated from field: repeated pathfinder.v1.OsmosisRoute routes = 1;
   */
  routes: OsmosisRoute[];

  /**
   * @generated from field: string liquidity_cap = 2;
   */
  liquidityCap: string;

  /**
   * @generated from field: bool liquidity_cap_overflow = 3;
   */
  liquidityCapOverflow: boolean;
};

/**
 * Describes the message pathfinder.v1.OsmosisRouteData.
 * Use `create(OsmosisRouteDataSchema)` to create a new message.
 */
export const OsmosisRouteDataSchema: GenMessage<OsmosisRouteData> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 9);

/**
 * @generated from message pathfinder.v1.OsmosisRoute
 */
export type OsmosisRoute = Message<"pathfinder.v1.OsmosisRoute"> & {
  /**
   * @generated from field: repeated pathfinder.v1.OsmosisPool pools = 1;
   */
  pools: OsmosisPool[];

  /**
   * @generated from field: bool has_cw_pool = 2;
   */
  hasCwPool: boolean;

  /**
   * @generated from field: string out_amount = 3;
   */
  outAmount: string;

  /**
   * @generated from field: string in_amount = 4;
   */
  inAmount: string;
};

/**
 * Describes the message pathfinder.v1.OsmosisRoute.
 * Use `create(OsmosisRouteSchema)` to create a new message.
 */
export const OsmosisRouteSchema: GenMessage<OsmosisRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 10);

/**
 * @generated from message pathfinder.v1.OsmosisPool
 */
export type OsmosisPool = Message<"pathfinder.v1.OsmosisPool"> & {
  /**
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * @generated from field: int32 type = 2;
   */
  type: number;

  /**
   * @generated from field: string spread_factor = 3;
   */
  spreadFactor: string;

  /**
   * @generated from field: string token_out_denom = 4;
   */
  tokenOutDenom: string;

  /**
   * @generated from field: string taker_fee = 5;
   */
  takerFee: string;

  /**
   * @generated from field: string liquidity_cap = 6;
   */
  liquidityCap: string;
};

/**
 * Describes the message pathfinder.v1.OsmosisPool.
 * Use `create(OsmosisPoolSchema)` to create a new message.
 */
export const OsmosisPoolSchema: GenMessage<OsmosisPool> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 11);

/**
 * LookupDenomRequest - Resolve token information
 * Accepts either:
 * - Human-readable denom (e.g., "uatone", "uosmo")
 * - IBC denom (e.g., "ibc/ABC123...")
 *
 * @generated from message pathfinder.v1.LookupDenomRequest
 */
export type LookupDenomRequest = Message<"pathfinder.v1.LookupDenomRequest"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: string denom = 2;
   */
  denom: string;
};

/**
 * Describes the message pathfinder.v1.LookupDenomRequest.
 * Use `create(LookupDenomRequestSchema)` to create a new message.
 */
export const LookupDenomRequestSchema: GenMessage<LookupDenomRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 12);

/**
 * @generated from message pathfinder.v1.LookupDenomResponse
 */
export type LookupDenomResponse = Message<"pathfinder.v1.LookupDenomResponse"> & {
  /**
   * @generated from field: bool found = 1;
   */
  found: boolean;

  /**
   * The denom as it appears on this chain
   *
   * @generated from field: string chain_denom = 2;
   */
  chainDenom: string;

  /**
   * The base/native denom
   *
   * @generated from field: string base_denom = 3;
   */
  baseDenom: string;

  /**
   * Where this token is native
   *
   * @generated from field: string origin_chain = 4;
   */
  originChain: string;

  /**
   * True if this is the token's native chain
   *
   * @generated from field: bool is_native = 5;
   */
  isNative: boolean;

  /**
   * IBC path if this is an IBC token (e.g., "transfer/channel-75")
   *
   * @generated from field: string ibc_path = 6;
   */
  ibcPath: string;

  /**
   * Denoms on other chains where this token is available
   *
   * @generated from field: repeated pathfinder.v1.ChainDenom available_on = 7;
   */
  availableOn: ChainDenom[];
};

/**
 * Describes the message pathfinder.v1.LookupDenomResponse.
 * Use `create(LookupDenomResponseSchema)` to create a new message.
 */
export const LookupDenomResponseSchema: GenMessage<LookupDenomResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 13);

/**
 * ChainDenom represents a token's denom on a specific chain
 *
 * @generated from message pathfinder.v1.ChainDenom
 */
export type ChainDenom = Message<"pathfinder.v1.ChainDenom"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: string chain_name = 2;
   */
  chainName: string;

  /**
   * @generated from field: string denom = 3;
   */
  denom: string;

  /**
   * @generated from field: bool is_native = 4;
   */
  isNative: boolean;
};

/**
 * Describes the message pathfinder.v1.ChainDenom.
 * Use `create(ChainDenomSchema)` to create a new message.
 */
export const ChainDenomSchema: GenMessage<ChainDenom> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 14);

/**
 * GetTokenDenomsRequest - Get all denoms for a token across chains
 * Use this to discover what denom a token has on different chains
 *
 * @generated from message pathfinder.v1.GetTokenDenomsRequest
 */
export type GetTokenDenomsRequest = Message<"pathfinder.v1.GetTokenDenomsRequest"> & {
  /**
   * The base denom (e.g., "uatone", "uosmo", "ustars")
   *
   * @generated from field: string base_denom = 1;
   */
  baseDenom: string;

  /**
   * The chain where this token is native (e.g., "atomone-1", "osmosis-1")
   *
   * @generated from field: string origin_chain = 2;
   */
  originChain: string;

  /**
   * Optional: Filter to a specific chain. If empty, returns denoms on all chains
   *
   * @generated from field: string on_chain_id = 3;
   */
  onChainId: string;
};

/**
 * Describes the message pathfinder.v1.GetTokenDenomsRequest.
 * Use `create(GetTokenDenomsRequestSchema)` to create a new message.
 */
export const GetTokenDenomsRequestSchema: GenMessage<GetTokenDenomsRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 15);

/**
 * @generated from message pathfinder.v1.GetTokenDenomsResponse
 */
export type GetTokenDenomsResponse = Message<"pathfinder.v1.GetTokenDenomsResponse"> & {
  /**
   * @generated from field: bool found = 1;
   */
  found: boolean;

  /**
   * @generated from field: string base_denom = 2;
   */
  baseDenom: string;

  /**
   * @generated from field: string origin_chain = 3;
   */
  originChain: string;

  /**
   * All chains where this token is available and what denom it has
   *
   * @generated from field: repeated pathfinder.v1.ChainDenom denoms = 4;
   */
  denoms: ChainDenom[];
};

/**
 * Describes the message pathfinder.v1.GetTokenDenomsResponse.
 * Use `create(GetTokenDenomsResponseSchema)` to create a new message.
 */
export const GetTokenDenomsResponseSchema: GenMessage<GetTokenDenomsResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 16);

/**
 * GetChainTokensRequest - Get all tokens on a chain
 *
 * @generated from message pathfinder.v1.GetChainTokensRequest
 */
export type GetChainTokensRequest = Message<"pathfinder.v1.GetChainTokensRequest"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;
};

/**
 * Describes the message pathfinder.v1.GetChainTokensRequest.
 * Use `create(GetChainTokensRequestSchema)` to create a new message.
 */
export const GetChainTokensRequestSchema: GenMessage<GetChainTokensRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 17);

/**
 * @generated from message pathfinder.v1.GetChainTokensResponse
 */
export type GetChainTokensResponse = Message<"pathfinder.v1.GetChainTokensResponse"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: string chain_name = 2;
   */
  chainName: string;

  /**
   * Native tokens on this chain
   *
   * @generated from field: repeated pathfinder.v1.TokenDetails native_tokens = 3;
   */
  nativeTokens: TokenDetails[];

  /**
   * IBC tokens received on this chain
   *
   * @generated from field: repeated pathfinder.v1.TokenDetails ibc_tokens = 4;
   */
  ibcTokens: TokenDetails[];
};

/**
 * Describes the message pathfinder.v1.GetChainTokensResponse.
 * Use `create(GetChainTokensResponseSchema)` to create a new message.
 */
export const GetChainTokensResponseSchema: GenMessage<GetChainTokensResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 18);

/**
 * TokenDetails - Full token information
 *
 * @generated from message pathfinder.v1.TokenDetails
 */
export type TokenDetails = Message<"pathfinder.v1.TokenDetails"> & {
  /**
   * Denom on this chain (native or IBC hash)
   *
   * @generated from field: string denom = 1;
   */
  denom: string;

  /**
   * Human-readable symbol (e.g., "ATONE", "OSMO")
   *
   * @generated from field: string symbol = 2;
   */
  symbol: string;

  /**
   * Base denom on origin chain
   *
   * @generated from field: string base_denom = 3;
   */
  baseDenom: string;

  /**
   * Chain where token is native
   *
   * @generated from field: string origin_chain = 4;
   */
  originChain: string;

  /**
   * Number of decimals
   *
   * @generated from field: int32 decimals = 5;
   */
  decimals: number;

  /**
   * True if native to this chain
   *
   * @generated from field: bool is_native = 6;
   */
  isNative: boolean;
};

/**
 * Describes the message pathfinder.v1.TokenDetails.
 * Use `create(TokenDetailsSchema)` to create a new message.
 */
export const TokenDetailsSchema: GenMessage<TokenDetails> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 19);

/**
 * @generated from message pathfinder.v1.PathfinderSupportedChainsResponse
 */
export type PathfinderSupportedChainsResponse = Message<"pathfinder.v1.PathfinderSupportedChainsResponse"> & {
  /**
   * @generated from field: repeated string chain_ids = 1;
   */
  chainIds: string[];
};

/**
 * Describes the message pathfinder.v1.PathfinderSupportedChainsResponse.
 * Use `create(PathfinderSupportedChainsResponseSchema)` to create a new message.
 */
export const PathfinderSupportedChainsResponseSchema: GenMessage<PathfinderSupportedChainsResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 20);

/**
 * @generated from message pathfinder.v1.ChainInfoRequest
 */
export type ChainInfoRequest = Message<"pathfinder.v1.ChainInfoRequest"> & {
  /**
   * The chain id of the chain to get information for
   *
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * Whether to show the symbols of the tokens on the chain, default is false
   *
   * @generated from field: bool show_symbols = 2;
   */
  showSymbols: boolean;
};

/**
 * Describes the message pathfinder.v1.ChainInfoRequest.
 * Use `create(ChainInfoRequestSchema)` to create a new message.
 */
export const ChainInfoRequestSchema: GenMessage<ChainInfoRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 21);

/**
 * @generated from message pathfinder.v1.ChainInfoResponse
 */
export type ChainInfoResponse = Message<"pathfinder.v1.ChainInfoResponse"> & {
  /**
   * @generated from field: pathfinder.v1.ChainInfo chain_info = 1;
   */
  chainInfo?: ChainInfo;
};

/**
 * Describes the message pathfinder.v1.ChainInfoResponse.
 * Use `create(ChainInfoResponseSchema)` to create a new message.
 */
export const ChainInfoResponseSchema: GenMessage<ChainInfoResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 22);

/**
 * @generated from message pathfinder.v1.ChainInfo
 */
export type ChainInfo = Message<"pathfinder.v1.ChainInfo"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: string chain_name = 2;
   */
  chainName: string;

  /**
   * @generated from field: bool has_pfm = 3;
   */
  hasPfm: boolean;

  /**
   * @generated from field: bool is_broker = 4;
   */
  isBroker: boolean;

  /**
   * @generated from field: repeated pathfinder.v1.BasicRoute routes = 5;
   */
  routes: BasicRoute[];
};

/**
 * Describes the message pathfinder.v1.ChainInfo.
 * Use `create(ChainInfoSchema)` to create a new message.
 */
export const ChainInfoSchema: GenMessage<ChainInfo> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 23);

/**
 * @generated from message pathfinder.v1.TokenInfo
 */
export type TokenInfo = Message<"pathfinder.v1.TokenInfo"> & {
  /**
   * @generated from field: string chain_denom = 1;
   */
  chainDenom: string;

  /**
   * @generated from field: string ibc_denom = 2;
   */
  ibcDenom: string;

  /**
   * @generated from field: string base_denom = 3;
   */
  baseDenom: string;

  /**
   * @generated from field: string origin_chain = 4;
   */
  originChain: string;

  /**
   * @generated from field: int32 decimals = 5;
   */
  decimals: number;

  /**
   * @generated from field: string symbol = 6;
   */
  symbol: string;
};

/**
 * Describes the message pathfinder.v1.TokenInfo.
 * Use `create(TokenInfoSchema)` to create a new message.
 */
export const TokenInfoSchema: GenMessage<TokenInfo> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 24);

/**
 * @generated from message pathfinder.v1.BasicRoute
 */
export type BasicRoute = Message<"pathfinder.v1.BasicRoute"> & {
  /**
   * @generated from field: string to_chain = 1;
   */
  toChain: string;

  /**
   * @generated from field: string to_chain_id = 2;
   */
  toChainId: string;

  /**
   * @generated from field: string connection_id = 3;
   */
  connectionId: string;

  /**
   * @generated from field: string channel_id = 4;
   */
  channelId: string;

  /**
   * @generated from field: string port_id = 5;
   */
  portId: string;

  /**
   * @generated from field: map<string, pathfinder.v1.TokenInfo> allowed_tokens = 6;
   */
  allowedTokens: { [key: string]: TokenInfo };
};

/**
 * Describes the message pathfinder.v1.BasicRoute.
 * Use `create(BasicRouteSchema)` to create a new message.
 */
export const BasicRouteSchema: GenMessage<BasicRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 25);

/**
 * PathfinderService provides route discovery and validation for IBC transfers and swaps
 *
 * @generated from service pathfinder.v1.PathfinderService
 */
export const PathfinderService: GenService<{
  /**
   * FindPath finds and validates a route between two chains
   * Supports human-readable denoms (e.g., "uatone") or IBC denoms
   *
   * @generated from rpc pathfinder.v1.PathfinderService.FindPath
   */
  findPath: {
    methodKind: "unary";
    input: typeof FindPathRequestSchema;
    output: typeof FindPathResponseSchema;
  },
  /**
   * LookupDenom resolves denom information on a specific chain
   * Accepts human-readable base denoms or IBC denom hashes
   *
   * @generated from rpc pathfinder.v1.PathfinderService.LookupDenom
   */
  lookupDenom: {
    methodKind: "unary";
    input: typeof LookupDenomRequestSchema;
    output: typeof LookupDenomResponseSchema;
  },
  /**
   * GetTokenDenoms returns all IBC denoms for a token across supported chains
   * Use this to discover what denom a token has on different chains
   *
   * @generated from rpc pathfinder.v1.PathfinderService.GetTokenDenoms
   */
  getTokenDenoms: {
    methodKind: "unary";
    input: typeof GetTokenDenomsRequestSchema;
    output: typeof GetTokenDenomsResponseSchema;
  },
  /**
   * GetChainInfo returns information about a specific chain
   *
   * @generated from rpc pathfinder.v1.PathfinderService.GetChainInfo
   */
  getChainInfo: {
    methodKind: "unary";
    input: typeof ChainInfoRequestSchema;
    output: typeof ChainInfoResponseSchema;
  },
  /**
   * ListSupportedChains returns a list of supported chains
   *
   * @generated from rpc pathfinder.v1.PathfinderService.ListSupportedChains
   */
  listSupportedChains: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof PathfinderSupportedChainsResponseSchema;
  },
  /**
   * GetChainTokens returns all tokens available on a specific chain
   * Includes both native tokens and IBC tokens with their denoms
   *
   * @generated from rpc pathfinder.v1.PathfinderService.GetChainTokens
   */
  getChainTokens: {
    methodKind: "unary";
    input: typeof GetChainTokensRequestSchema;
    output: typeof GetChainTokensResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_pathfinder_route, 0);

