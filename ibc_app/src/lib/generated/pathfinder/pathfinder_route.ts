// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               unknown
// source: pathfinder_route.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty } from "./google/protobuf/empty";

export const protobufPackage = "rpc.v1";

/**
 * FindPathRequest - Find a route between chains
 *
 * For token_from_denom and token_to_denom, you can use:
 * - Human-readable denom (e.g., "uatone", "uosmo", "ustars")
 * - Full IBC denom (e.g., "ibc/ABC123...")
 *
 * The pathfinder will automatically resolve human-readable denoms.
 * If token_to_denom is empty, the pathfinder assumes you want the same token
 * on the destination chain (useful for bridging without swapping).
 */
export interface FindPathRequest {
  /** Source chain ID (e.g., "osmosis-1", "atomone-1") */
  chainFrom: string;
  /**
   * Token denom on source chain - can be human-readable (e.g., "uatone")
   * or IBC denom (e.g., "ibc/...")
   */
  tokenFromDenom: string;
  /** Amount to transfer/swap (in base units) */
  amountIn: string;
  /** Destination chain ID */
  chainTo: string;
  /**
   * Token denom you want to receive on destination chain
   * Can be human-readable (e.g., "uosmo") or IBC denom
   * If empty, assumes same token as token_from (bridging without swap)
   */
  tokenToDenom: string;
  /** Sender address on source chain */
  senderAddress: string;
  /** Receiver address on destination chain */
  receiverAddress: string;
  /** If true, only return a single route, if false, return all possible routes */
  singleRoute: boolean;
  /**
   * Slippage in basis points (e.g., 100 = 1%, 1000 = 10%)
   * Must be less than 10000
   */
  slippageBps: number;
}

export interface FindPathResponse {
  success: boolean;
  errorMessage: string;
  direct?: DirectRoute | undefined;
  indirect?: IndirectRoute | undefined;
  brokerSwap?: BrokerSwapRoute | undefined;
}

export interface DirectRoute {
  transfer: IBCLeg | undefined;
}

export interface IndirectRoute {
  path: string[];
  legs: IBCLeg[];
  supportsPfm: boolean;
  pfmStartChain: string;
  pfmMemo: string;
}

/**
 * BrokerSwapRoute represents a route involving a swap on a broker chain.
 * Supports various scenarios:
 * - Same-chain swap: inbound_leg absent, outbound_legs=[] (e.g., osmosis ATOM -> osmosis OSMO)
 * - Swap from broker: inbound_leg absent (e.g., osmosis USDC -> juno JUNO)
 * - Standard 3-chain: inbound_leg set, len(outbound_legs)=1
 * - Multi-hop outbound: inbound_leg set, len(outbound_legs)>1 (e.g., cosmos ATOM -> swap -> noble -> juno)
 */
export interface BrokerSwapRoute {
  /** All chain IDs in order */
  path: string[];
  /** IBC transfer to reach broker (absent if starting from broker) */
  inboundLeg:
    | IBCLeg
    | undefined;
  /** The swap operation on the broker chain */
  swap:
    | SwapQuote
    | undefined;
  /**
   * IBC transfers after swap (empty if destination is broker)
   * Can be multiple for multi-hop forwarding via PFM
   */
  outboundLegs: IBCLeg[];
  /** Can use PFM for outbound legs */
  outboundSupportsPfm: boolean;
  /** Execution data for building transactions */
  execution: BrokerExecutionData | undefined;
}

/** BrokerExecutionData contains ready-to-use transaction data */
export interface BrokerExecutionData {
  /** The IBC memo to use with MsgTransfer (contains wasm swap_and_action) */
  memo: string;
  /** Receiver address for MsgTransfer (the ibc-hooks contract) */
  ibcReceiver: string;
  /** Recovery address on broker chain (where funds go if swap/forward fails) */
  recoverAddress: string;
  /** Minimum output amount after slippage (1% default) */
  minOutputAmount: string;
  /** True if using wasm ibc-hooks (vs simple PFM) */
  usesWasm: boolean;
  /** Human-readable description */
  description: string;
}

export interface IBCLeg {
  fromChain: string;
  toChain: string;
  channel: string;
  port: string;
  token: TokenMapping | undefined;
  amount: string;
}

export interface TokenMapping {
  /** The denom as it appears on the current chain (native or IBC) */
  chainDenom: string;
  /** The base/native denom on the token's origin chain */
  baseDenom: string;
  /** The chain ID where this token is native */
  originChain: string;
  /** True if this is the token's native chain */
  isNative: boolean;
}

/** SwapQuote with broker-specific route data */
export interface SwapQuote {
  broker: string;
  tokenIn: TokenMapping | undefined;
  tokenOut: TokenMapping | undefined;
  amountIn: string;
  amountOut: string;
  priceImpact: string;
  effectiveFee: string;
  /** Future brokers can be added here without breaking existing clients */
  osmosisRouteData?: OsmosisRouteData | undefined;
}

/** Osmosis-specific route data (from SQS API) */
export interface OsmosisRouteData {
  routes: OsmosisRoute[];
  liquidityCap: string;
  liquidityCapOverflow: boolean;
}

export interface OsmosisRoute {
  pools: OsmosisPool[];
  hasCwPool: boolean;
  outAmount: string;
  inAmount: string;
}

export interface OsmosisPool {
  id: number;
  type: number;
  spreadFactor: string;
  tokenOutDenom: string;
  takerFee: string;
  liquidityCap: string;
}

/**
 * LookupDenomRequest - Resolve token information
 * Accepts either:
 * - Human-readable denom (e.g., "uatone", "uosmo")
 * - IBC denom (e.g., "ibc/ABC123...")
 */
export interface LookupDenomRequest {
  chainId: string;
  denom: string;
}

export interface LookupDenomResponse {
  found: boolean;
  /** The denom as it appears on this chain */
  chainDenom: string;
  /** The base/native denom */
  baseDenom: string;
  /** Where this token is native */
  originChain: string;
  /** True if this is the token's native chain */
  isNative: boolean;
  /** IBC path if this is an IBC token (e.g., "transfer/channel-75") */
  ibcPath: string;
  /** Denoms on other chains where this token is available */
  availableOn: ChainDenom[];
}

/** ChainDenom represents a token's denom on a specific chain */
export interface ChainDenom {
  chainId: string;
  chainName: string;
  denom: string;
  isNative: boolean;
}

/**
 * GetTokenDenomsRequest - Get all denoms for a token across chains
 * Use this to discover what denom a token has on different chains
 */
export interface GetTokenDenomsRequest {
  /** The base denom (e.g., "uatone", "uosmo", "ustars") */
  baseDenom: string;
  /** The chain where this token is native (e.g., "atomone-1", "osmosis-1") */
  originChain: string;
  /** Optional: Filter to a specific chain. If empty, returns denoms on all chains */
  onChainId: string;
}

export interface GetTokenDenomsResponse {
  found: boolean;
  baseDenom: string;
  originChain: string;
  /** All chains where this token is available and what denom it has */
  denoms: ChainDenom[];
}

/** GetChainTokensRequest - Get all tokens on a chain */
export interface GetChainTokensRequest {
  chainId: string;
}

export interface GetChainTokensResponse {
  chainId: string;
  chainName: string;
  /** Native tokens on this chain */
  nativeTokens: TokenDetails[];
  /** IBC tokens received on this chain */
  ibcTokens: TokenDetails[];
}

/** TokenDetails - Full token information */
export interface TokenDetails {
  /** Denom on this chain (native or IBC hash) */
  denom: string;
  /** Human-readable symbol (e.g., "ATONE", "OSMO") */
  symbol: string;
  /** Base denom on origin chain */
  baseDenom: string;
  /** Chain where token is native */
  originChain: string;
  /** Number of decimals */
  decimals: number;
  /** True if native to this chain */
  isNative: boolean;
}

export interface PathfinderSupportedChainsResponse {
  chainIds: string[];
}

export interface ChainInfoRequest {
  chainId: string;
  sortBySymbol: boolean;
}

export interface ChainInfoResponse {
  chainInfo: ChainInfo | undefined;
}

export interface ChainInfo {
  chainId: string;
  chainName: string;
  hasPfm: boolean;
  isBroker: boolean;
  routes: BasicRoute[];
}

export interface TokenInfo {
  chainDenom: string;
  ibcDenom: string;
  baseDenom: string;
  originChain: string;
  decimals: number;
  symbol: string;
}

export interface BasicRoute {
  toChain: string;
  toChainId: string;
  connectionId: string;
  channelId: string;
  portId: string;
  allowedTokens: { [key: string]: TokenInfo };
}

export interface BasicRoute_AllowedTokensEntry {
  key: string;
  value: TokenInfo | undefined;
}

function createBaseFindPathRequest(): FindPathRequest {
  return {
    chainFrom: "",
    tokenFromDenom: "",
    amountIn: "",
    chainTo: "",
    tokenToDenom: "",
    senderAddress: "",
    receiverAddress: "",
    singleRoute: false,
    slippageBps: 0,
  };
}

export const FindPathRequest: MessageFns<FindPathRequest> = {
  encode(message: FindPathRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainFrom !== "") {
      writer.uint32(10).string(message.chainFrom);
    }
    if (message.tokenFromDenom !== "") {
      writer.uint32(18).string(message.tokenFromDenom);
    }
    if (message.amountIn !== "") {
      writer.uint32(26).string(message.amountIn);
    }
    if (message.chainTo !== "") {
      writer.uint32(34).string(message.chainTo);
    }
    if (message.tokenToDenom !== "") {
      writer.uint32(42).string(message.tokenToDenom);
    }
    if (message.senderAddress !== "") {
      writer.uint32(50).string(message.senderAddress);
    }
    if (message.receiverAddress !== "") {
      writer.uint32(58).string(message.receiverAddress);
    }
    if (message.singleRoute !== false) {
      writer.uint32(64).bool(message.singleRoute);
    }
    if (message.slippageBps !== 0) {
      writer.uint32(72).uint32(message.slippageBps);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindPathRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindPathRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainFrom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenFromDenom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.chainTo = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tokenToDenom = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.senderAddress = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.receiverAddress = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.singleRoute = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.slippageBps = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindPathRequest {
    return {
      chainFrom: isSet(object.chainFrom) ? globalThis.String(object.chainFrom) : "",
      tokenFromDenom: isSet(object.tokenFromDenom) ? globalThis.String(object.tokenFromDenom) : "",
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      chainTo: isSet(object.chainTo) ? globalThis.String(object.chainTo) : "",
      tokenToDenom: isSet(object.tokenToDenom) ? globalThis.String(object.tokenToDenom) : "",
      senderAddress: isSet(object.senderAddress) ? globalThis.String(object.senderAddress) : "",
      receiverAddress: isSet(object.receiverAddress) ? globalThis.String(object.receiverAddress) : "",
      singleRoute: isSet(object.singleRoute) ? globalThis.Boolean(object.singleRoute) : false,
      slippageBps: isSet(object.slippageBps) ? globalThis.Number(object.slippageBps) : 0,
    };
  },

  toJSON(message: FindPathRequest): unknown {
    const obj: any = {};
    if (message.chainFrom !== "") {
      obj.chainFrom = message.chainFrom;
    }
    if (message.tokenFromDenom !== "") {
      obj.tokenFromDenom = message.tokenFromDenom;
    }
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    if (message.chainTo !== "") {
      obj.chainTo = message.chainTo;
    }
    if (message.tokenToDenom !== "") {
      obj.tokenToDenom = message.tokenToDenom;
    }
    if (message.senderAddress !== "") {
      obj.senderAddress = message.senderAddress;
    }
    if (message.receiverAddress !== "") {
      obj.receiverAddress = message.receiverAddress;
    }
    if (message.singleRoute !== false) {
      obj.singleRoute = message.singleRoute;
    }
    if (message.slippageBps !== 0) {
      obj.slippageBps = Math.round(message.slippageBps);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindPathRequest>, I>>(base?: I): FindPathRequest {
    return FindPathRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindPathRequest>, I>>(object: I): FindPathRequest {
    const message = createBaseFindPathRequest();
    message.chainFrom = object.chainFrom ?? "";
    message.tokenFromDenom = object.tokenFromDenom ?? "";
    message.amountIn = object.amountIn ?? "";
    message.chainTo = object.chainTo ?? "";
    message.tokenToDenom = object.tokenToDenom ?? "";
    message.senderAddress = object.senderAddress ?? "";
    message.receiverAddress = object.receiverAddress ?? "";
    message.singleRoute = object.singleRoute ?? false;
    message.slippageBps = object.slippageBps ?? 0;
    return message;
  },
};

function createBaseFindPathResponse(): FindPathResponse {
  return { success: false, errorMessage: "", direct: undefined, indirect: undefined, brokerSwap: undefined };
}

export const FindPathResponse: MessageFns<FindPathResponse> = {
  encode(message: FindPathResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.direct !== undefined) {
      DirectRoute.encode(message.direct, writer.uint32(26).fork()).join();
    }
    if (message.indirect !== undefined) {
      IndirectRoute.encode(message.indirect, writer.uint32(34).fork()).join();
    }
    if (message.brokerSwap !== undefined) {
      BrokerSwapRoute.encode(message.brokerSwap, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindPathResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindPathResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.direct = DirectRoute.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.indirect = IndirectRoute.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.brokerSwap = BrokerSwapRoute.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindPathResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      direct: isSet(object.direct) ? DirectRoute.fromJSON(object.direct) : undefined,
      indirect: isSet(object.indirect) ? IndirectRoute.fromJSON(object.indirect) : undefined,
      brokerSwap: isSet(object.brokerSwap) ? BrokerSwapRoute.fromJSON(object.brokerSwap) : undefined,
    };
  },

  toJSON(message: FindPathResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.direct !== undefined) {
      obj.direct = DirectRoute.toJSON(message.direct);
    }
    if (message.indirect !== undefined) {
      obj.indirect = IndirectRoute.toJSON(message.indirect);
    }
    if (message.brokerSwap !== undefined) {
      obj.brokerSwap = BrokerSwapRoute.toJSON(message.brokerSwap);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindPathResponse>, I>>(base?: I): FindPathResponse {
    return FindPathResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindPathResponse>, I>>(object: I): FindPathResponse {
    const message = createBaseFindPathResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? "";
    message.direct = (object.direct !== undefined && object.direct !== null)
      ? DirectRoute.fromPartial(object.direct)
      : undefined;
    message.indirect = (object.indirect !== undefined && object.indirect !== null)
      ? IndirectRoute.fromPartial(object.indirect)
      : undefined;
    message.brokerSwap = (object.brokerSwap !== undefined && object.brokerSwap !== null)
      ? BrokerSwapRoute.fromPartial(object.brokerSwap)
      : undefined;
    return message;
  },
};

function createBaseDirectRoute(): DirectRoute {
  return { transfer: undefined };
}

export const DirectRoute: MessageFns<DirectRoute> = {
  encode(message: DirectRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      IBCLeg.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DirectRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDirectRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = IBCLeg.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DirectRoute {
    return { transfer: isSet(object.transfer) ? IBCLeg.fromJSON(object.transfer) : undefined };
  },

  toJSON(message: DirectRoute): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = IBCLeg.toJSON(message.transfer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DirectRoute>, I>>(base?: I): DirectRoute {
    return DirectRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DirectRoute>, I>>(object: I): DirectRoute {
    const message = createBaseDirectRoute();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? IBCLeg.fromPartial(object.transfer)
      : undefined;
    return message;
  },
};

function createBaseIndirectRoute(): IndirectRoute {
  return { path: [], legs: [], supportsPfm: false, pfmStartChain: "", pfmMemo: "" };
}

export const IndirectRoute: MessageFns<IndirectRoute> = {
  encode(message: IndirectRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.path) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.legs) {
      IBCLeg.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.supportsPfm !== false) {
      writer.uint32(24).bool(message.supportsPfm);
    }
    if (message.pfmStartChain !== "") {
      writer.uint32(34).string(message.pfmStartChain);
    }
    if (message.pfmMemo !== "") {
      writer.uint32(42).string(message.pfmMemo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IndirectRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIndirectRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.legs.push(IBCLeg.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.supportsPfm = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pfmStartChain = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pfmMemo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IndirectRoute {
    return {
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => globalThis.String(e)) : [],
      legs: globalThis.Array.isArray(object?.legs) ? object.legs.map((e: any) => IBCLeg.fromJSON(e)) : [],
      supportsPfm: isSet(object.supportsPfm) ? globalThis.Boolean(object.supportsPfm) : false,
      pfmStartChain: isSet(object.pfmStartChain) ? globalThis.String(object.pfmStartChain) : "",
      pfmMemo: isSet(object.pfmMemo) ? globalThis.String(object.pfmMemo) : "",
    };
  },

  toJSON(message: IndirectRoute): unknown {
    const obj: any = {};
    if (message.path?.length) {
      obj.path = message.path;
    }
    if (message.legs?.length) {
      obj.legs = message.legs.map((e) => IBCLeg.toJSON(e));
    }
    if (message.supportsPfm !== false) {
      obj.supportsPfm = message.supportsPfm;
    }
    if (message.pfmStartChain !== "") {
      obj.pfmStartChain = message.pfmStartChain;
    }
    if (message.pfmMemo !== "") {
      obj.pfmMemo = message.pfmMemo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IndirectRoute>, I>>(base?: I): IndirectRoute {
    return IndirectRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IndirectRoute>, I>>(object: I): IndirectRoute {
    const message = createBaseIndirectRoute();
    message.path = object.path?.map((e) => e) || [];
    message.legs = object.legs?.map((e) => IBCLeg.fromPartial(e)) || [];
    message.supportsPfm = object.supportsPfm ?? false;
    message.pfmStartChain = object.pfmStartChain ?? "";
    message.pfmMemo = object.pfmMemo ?? "";
    return message;
  },
};

function createBaseBrokerSwapRoute(): BrokerSwapRoute {
  return {
    path: [],
    inboundLeg: undefined,
    swap: undefined,
    outboundLegs: [],
    outboundSupportsPfm: false,
    execution: undefined,
  };
}

export const BrokerSwapRoute: MessageFns<BrokerSwapRoute> = {
  encode(message: BrokerSwapRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.path) {
      writer.uint32(10).string(v!);
    }
    if (message.inboundLeg !== undefined) {
      IBCLeg.encode(message.inboundLeg, writer.uint32(18).fork()).join();
    }
    if (message.swap !== undefined) {
      SwapQuote.encode(message.swap, writer.uint32(26).fork()).join();
    }
    for (const v of message.outboundLegs) {
      IBCLeg.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.outboundSupportsPfm !== false) {
      writer.uint32(40).bool(message.outboundSupportsPfm);
    }
    if (message.execution !== undefined) {
      BrokerExecutionData.encode(message.execution, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrokerSwapRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrokerSwapRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inboundLeg = IBCLeg.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.swap = SwapQuote.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outboundLegs.push(IBCLeg.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.outboundSupportsPfm = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.execution = BrokerExecutionData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrokerSwapRoute {
    return {
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => globalThis.String(e)) : [],
      inboundLeg: isSet(object.inboundLeg) ? IBCLeg.fromJSON(object.inboundLeg) : undefined,
      swap: isSet(object.swap) ? SwapQuote.fromJSON(object.swap) : undefined,
      outboundLegs: globalThis.Array.isArray(object?.outboundLegs)
        ? object.outboundLegs.map((e: any) => IBCLeg.fromJSON(e))
        : [],
      outboundSupportsPfm: isSet(object.outboundSupportsPfm) ? globalThis.Boolean(object.outboundSupportsPfm) : false,
      execution: isSet(object.execution) ? BrokerExecutionData.fromJSON(object.execution) : undefined,
    };
  },

  toJSON(message: BrokerSwapRoute): unknown {
    const obj: any = {};
    if (message.path?.length) {
      obj.path = message.path;
    }
    if (message.inboundLeg !== undefined) {
      obj.inboundLeg = IBCLeg.toJSON(message.inboundLeg);
    }
    if (message.swap !== undefined) {
      obj.swap = SwapQuote.toJSON(message.swap);
    }
    if (message.outboundLegs?.length) {
      obj.outboundLegs = message.outboundLegs.map((e) => IBCLeg.toJSON(e));
    }
    if (message.outboundSupportsPfm !== false) {
      obj.outboundSupportsPfm = message.outboundSupportsPfm;
    }
    if (message.execution !== undefined) {
      obj.execution = BrokerExecutionData.toJSON(message.execution);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BrokerSwapRoute>, I>>(base?: I): BrokerSwapRoute {
    return BrokerSwapRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BrokerSwapRoute>, I>>(object: I): BrokerSwapRoute {
    const message = createBaseBrokerSwapRoute();
    message.path = object.path?.map((e) => e) || [];
    message.inboundLeg = (object.inboundLeg !== undefined && object.inboundLeg !== null)
      ? IBCLeg.fromPartial(object.inboundLeg)
      : undefined;
    message.swap = (object.swap !== undefined && object.swap !== null) ? SwapQuote.fromPartial(object.swap) : undefined;
    message.outboundLegs = object.outboundLegs?.map((e) => IBCLeg.fromPartial(e)) || [];
    message.outboundSupportsPfm = object.outboundSupportsPfm ?? false;
    message.execution = (object.execution !== undefined && object.execution !== null)
      ? BrokerExecutionData.fromPartial(object.execution)
      : undefined;
    return message;
  },
};

function createBaseBrokerExecutionData(): BrokerExecutionData {
  return { memo: "", ibcReceiver: "", recoverAddress: "", minOutputAmount: "", usesWasm: false, description: "" };
}

export const BrokerExecutionData: MessageFns<BrokerExecutionData> = {
  encode(message: BrokerExecutionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.memo !== "") {
      writer.uint32(10).string(message.memo);
    }
    if (message.ibcReceiver !== "") {
      writer.uint32(18).string(message.ibcReceiver);
    }
    if (message.recoverAddress !== "") {
      writer.uint32(26).string(message.recoverAddress);
    }
    if (message.minOutputAmount !== "") {
      writer.uint32(34).string(message.minOutputAmount);
    }
    if (message.usesWasm !== false) {
      writer.uint32(40).bool(message.usesWasm);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrokerExecutionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrokerExecutionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.memo = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ibcReceiver = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.recoverAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.minOutputAmount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.usesWasm = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BrokerExecutionData {
    return {
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      ibcReceiver: isSet(object.ibcReceiver) ? globalThis.String(object.ibcReceiver) : "",
      recoverAddress: isSet(object.recoverAddress) ? globalThis.String(object.recoverAddress) : "",
      minOutputAmount: isSet(object.minOutputAmount) ? globalThis.String(object.minOutputAmount) : "",
      usesWasm: isSet(object.usesWasm) ? globalThis.Boolean(object.usesWasm) : false,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: BrokerExecutionData): unknown {
    const obj: any = {};
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.ibcReceiver !== "") {
      obj.ibcReceiver = message.ibcReceiver;
    }
    if (message.recoverAddress !== "") {
      obj.recoverAddress = message.recoverAddress;
    }
    if (message.minOutputAmount !== "") {
      obj.minOutputAmount = message.minOutputAmount;
    }
    if (message.usesWasm !== false) {
      obj.usesWasm = message.usesWasm;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BrokerExecutionData>, I>>(base?: I): BrokerExecutionData {
    return BrokerExecutionData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BrokerExecutionData>, I>>(object: I): BrokerExecutionData {
    const message = createBaseBrokerExecutionData();
    message.memo = object.memo ?? "";
    message.ibcReceiver = object.ibcReceiver ?? "";
    message.recoverAddress = object.recoverAddress ?? "";
    message.minOutputAmount = object.minOutputAmount ?? "";
    message.usesWasm = object.usesWasm ?? false;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseIBCLeg(): IBCLeg {
  return { fromChain: "", toChain: "", channel: "", port: "", token: undefined, amount: "" };
}

export const IBCLeg: MessageFns<IBCLeg> = {
  encode(message: IBCLeg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromChain !== "") {
      writer.uint32(10).string(message.fromChain);
    }
    if (message.toChain !== "") {
      writer.uint32(18).string(message.toChain);
    }
    if (message.channel !== "") {
      writer.uint32(26).string(message.channel);
    }
    if (message.port !== "") {
      writer.uint32(34).string(message.port);
    }
    if (message.token !== undefined) {
      TokenMapping.encode(message.token, writer.uint32(42).fork()).join();
    }
    if (message.amount !== "") {
      writer.uint32(50).string(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IBCLeg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIBCLeg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fromChain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toChain = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channel = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.port = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.token = TokenMapping.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IBCLeg {
    return {
      fromChain: isSet(object.fromChain) ? globalThis.String(object.fromChain) : "",
      toChain: isSet(object.toChain) ? globalThis.String(object.toChain) : "",
      channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
      port: isSet(object.port) ? globalThis.String(object.port) : "",
      token: isSet(object.token) ? TokenMapping.fromJSON(object.token) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: IBCLeg): unknown {
    const obj: any = {};
    if (message.fromChain !== "") {
      obj.fromChain = message.fromChain;
    }
    if (message.toChain !== "") {
      obj.toChain = message.toChain;
    }
    if (message.channel !== "") {
      obj.channel = message.channel;
    }
    if (message.port !== "") {
      obj.port = message.port;
    }
    if (message.token !== undefined) {
      obj.token = TokenMapping.toJSON(message.token);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IBCLeg>, I>>(base?: I): IBCLeg {
    return IBCLeg.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IBCLeg>, I>>(object: I): IBCLeg {
    const message = createBaseIBCLeg();
    message.fromChain = object.fromChain ?? "";
    message.toChain = object.toChain ?? "";
    message.channel = object.channel ?? "";
    message.port = object.port ?? "";
    message.token = (object.token !== undefined && object.token !== null)
      ? TokenMapping.fromPartial(object.token)
      : undefined;
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseTokenMapping(): TokenMapping {
  return { chainDenom: "", baseDenom: "", originChain: "", isNative: false };
}

export const TokenMapping: MessageFns<TokenMapping> = {
  encode(message: TokenMapping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainDenom !== "") {
      writer.uint32(10).string(message.chainDenom);
    }
    if (message.baseDenom !== "") {
      writer.uint32(18).string(message.baseDenom);
    }
    if (message.originChain !== "") {
      writer.uint32(26).string(message.originChain);
    }
    if (message.isNative !== false) {
      writer.uint32(32).bool(message.isNative);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenMapping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenMapping();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainDenom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseDenom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.originChain = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isNative = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenMapping {
    return {
      chainDenom: isSet(object.chainDenom) ? globalThis.String(object.chainDenom) : "",
      baseDenom: isSet(object.baseDenom) ? globalThis.String(object.baseDenom) : "",
      originChain: isSet(object.originChain) ? globalThis.String(object.originChain) : "",
      isNative: isSet(object.isNative) ? globalThis.Boolean(object.isNative) : false,
    };
  },

  toJSON(message: TokenMapping): unknown {
    const obj: any = {};
    if (message.chainDenom !== "") {
      obj.chainDenom = message.chainDenom;
    }
    if (message.baseDenom !== "") {
      obj.baseDenom = message.baseDenom;
    }
    if (message.originChain !== "") {
      obj.originChain = message.originChain;
    }
    if (message.isNative !== false) {
      obj.isNative = message.isNative;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenMapping>, I>>(base?: I): TokenMapping {
    return TokenMapping.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenMapping>, I>>(object: I): TokenMapping {
    const message = createBaseTokenMapping();
    message.chainDenom = object.chainDenom ?? "";
    message.baseDenom = object.baseDenom ?? "";
    message.originChain = object.originChain ?? "";
    message.isNative = object.isNative ?? false;
    return message;
  },
};

function createBaseSwapQuote(): SwapQuote {
  return {
    broker: "",
    tokenIn: undefined,
    tokenOut: undefined,
    amountIn: "",
    amountOut: "",
    priceImpact: "",
    effectiveFee: "",
    osmosisRouteData: undefined,
  };
}

export const SwapQuote: MessageFns<SwapQuote> = {
  encode(message: SwapQuote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.broker !== "") {
      writer.uint32(10).string(message.broker);
    }
    if (message.tokenIn !== undefined) {
      TokenMapping.encode(message.tokenIn, writer.uint32(18).fork()).join();
    }
    if (message.tokenOut !== undefined) {
      TokenMapping.encode(message.tokenOut, writer.uint32(26).fork()).join();
    }
    if (message.amountIn !== "") {
      writer.uint32(34).string(message.amountIn);
    }
    if (message.amountOut !== "") {
      writer.uint32(42).string(message.amountOut);
    }
    if (message.priceImpact !== "") {
      writer.uint32(50).string(message.priceImpact);
    }
    if (message.effectiveFee !== "") {
      writer.uint32(58).string(message.effectiveFee);
    }
    if (message.osmosisRouteData !== undefined) {
      OsmosisRouteData.encode(message.osmosisRouteData, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SwapQuote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwapQuote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.broker = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenIn = TokenMapping.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenOut = TokenMapping.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amountIn = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.amountOut = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.priceImpact = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.effectiveFee = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.osmosisRouteData = OsmosisRouteData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SwapQuote {
    return {
      broker: isSet(object.broker) ? globalThis.String(object.broker) : "",
      tokenIn: isSet(object.tokenIn) ? TokenMapping.fromJSON(object.tokenIn) : undefined,
      tokenOut: isSet(object.tokenOut) ? TokenMapping.fromJSON(object.tokenOut) : undefined,
      amountIn: isSet(object.amountIn) ? globalThis.String(object.amountIn) : "",
      amountOut: isSet(object.amountOut) ? globalThis.String(object.amountOut) : "",
      priceImpact: isSet(object.priceImpact) ? globalThis.String(object.priceImpact) : "",
      effectiveFee: isSet(object.effectiveFee) ? globalThis.String(object.effectiveFee) : "",
      osmosisRouteData: isSet(object.osmosisRouteData) ? OsmosisRouteData.fromJSON(object.osmosisRouteData) : undefined,
    };
  },

  toJSON(message: SwapQuote): unknown {
    const obj: any = {};
    if (message.broker !== "") {
      obj.broker = message.broker;
    }
    if (message.tokenIn !== undefined) {
      obj.tokenIn = TokenMapping.toJSON(message.tokenIn);
    }
    if (message.tokenOut !== undefined) {
      obj.tokenOut = TokenMapping.toJSON(message.tokenOut);
    }
    if (message.amountIn !== "") {
      obj.amountIn = message.amountIn;
    }
    if (message.amountOut !== "") {
      obj.amountOut = message.amountOut;
    }
    if (message.priceImpact !== "") {
      obj.priceImpact = message.priceImpact;
    }
    if (message.effectiveFee !== "") {
      obj.effectiveFee = message.effectiveFee;
    }
    if (message.osmosisRouteData !== undefined) {
      obj.osmosisRouteData = OsmosisRouteData.toJSON(message.osmosisRouteData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SwapQuote>, I>>(base?: I): SwapQuote {
    return SwapQuote.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SwapQuote>, I>>(object: I): SwapQuote {
    const message = createBaseSwapQuote();
    message.broker = object.broker ?? "";
    message.tokenIn = (object.tokenIn !== undefined && object.tokenIn !== null)
      ? TokenMapping.fromPartial(object.tokenIn)
      : undefined;
    message.tokenOut = (object.tokenOut !== undefined && object.tokenOut !== null)
      ? TokenMapping.fromPartial(object.tokenOut)
      : undefined;
    message.amountIn = object.amountIn ?? "";
    message.amountOut = object.amountOut ?? "";
    message.priceImpact = object.priceImpact ?? "";
    message.effectiveFee = object.effectiveFee ?? "";
    message.osmosisRouteData = (object.osmosisRouteData !== undefined && object.osmosisRouteData !== null)
      ? OsmosisRouteData.fromPartial(object.osmosisRouteData)
      : undefined;
    return message;
  },
};

function createBaseOsmosisRouteData(): OsmosisRouteData {
  return { routes: [], liquidityCap: "", liquidityCapOverflow: false };
}

export const OsmosisRouteData: MessageFns<OsmosisRouteData> = {
  encode(message: OsmosisRouteData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.routes) {
      OsmosisRoute.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.liquidityCap !== "") {
      writer.uint32(18).string(message.liquidityCap);
    }
    if (message.liquidityCapOverflow !== false) {
      writer.uint32(24).bool(message.liquidityCapOverflow);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OsmosisRouteData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOsmosisRouteData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routes.push(OsmosisRoute.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.liquidityCap = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.liquidityCapOverflow = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OsmosisRouteData {
    return {
      routes: globalThis.Array.isArray(object?.routes) ? object.routes.map((e: any) => OsmosisRoute.fromJSON(e)) : [],
      liquidityCap: isSet(object.liquidityCap) ? globalThis.String(object.liquidityCap) : "",
      liquidityCapOverflow: isSet(object.liquidityCapOverflow)
        ? globalThis.Boolean(object.liquidityCapOverflow)
        : false,
    };
  },

  toJSON(message: OsmosisRouteData): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => OsmosisRoute.toJSON(e));
    }
    if (message.liquidityCap !== "") {
      obj.liquidityCap = message.liquidityCap;
    }
    if (message.liquidityCapOverflow !== false) {
      obj.liquidityCapOverflow = message.liquidityCapOverflow;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OsmosisRouteData>, I>>(base?: I): OsmosisRouteData {
    return OsmosisRouteData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OsmosisRouteData>, I>>(object: I): OsmosisRouteData {
    const message = createBaseOsmosisRouteData();
    message.routes = object.routes?.map((e) => OsmosisRoute.fromPartial(e)) || [];
    message.liquidityCap = object.liquidityCap ?? "";
    message.liquidityCapOverflow = object.liquidityCapOverflow ?? false;
    return message;
  },
};

function createBaseOsmosisRoute(): OsmosisRoute {
  return { pools: [], hasCwPool: false, outAmount: "", inAmount: "" };
}

export const OsmosisRoute: MessageFns<OsmosisRoute> = {
  encode(message: OsmosisRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pools) {
      OsmosisPool.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.hasCwPool !== false) {
      writer.uint32(16).bool(message.hasCwPool);
    }
    if (message.outAmount !== "") {
      writer.uint32(26).string(message.outAmount);
    }
    if (message.inAmount !== "") {
      writer.uint32(34).string(message.inAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OsmosisRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOsmosisRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pools.push(OsmosisPool.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hasCwPool = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outAmount = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inAmount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OsmosisRoute {
    return {
      pools: globalThis.Array.isArray(object?.pools) ? object.pools.map((e: any) => OsmosisPool.fromJSON(e)) : [],
      hasCwPool: isSet(object.hasCwPool) ? globalThis.Boolean(object.hasCwPool) : false,
      outAmount: isSet(object.outAmount) ? globalThis.String(object.outAmount) : "",
      inAmount: isSet(object.inAmount) ? globalThis.String(object.inAmount) : "",
    };
  },

  toJSON(message: OsmosisRoute): unknown {
    const obj: any = {};
    if (message.pools?.length) {
      obj.pools = message.pools.map((e) => OsmosisPool.toJSON(e));
    }
    if (message.hasCwPool !== false) {
      obj.hasCwPool = message.hasCwPool;
    }
    if (message.outAmount !== "") {
      obj.outAmount = message.outAmount;
    }
    if (message.inAmount !== "") {
      obj.inAmount = message.inAmount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OsmosisRoute>, I>>(base?: I): OsmosisRoute {
    return OsmosisRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OsmosisRoute>, I>>(object: I): OsmosisRoute {
    const message = createBaseOsmosisRoute();
    message.pools = object.pools?.map((e) => OsmosisPool.fromPartial(e)) || [];
    message.hasCwPool = object.hasCwPool ?? false;
    message.outAmount = object.outAmount ?? "";
    message.inAmount = object.inAmount ?? "";
    return message;
  },
};

function createBaseOsmosisPool(): OsmosisPool {
  return { id: 0, type: 0, spreadFactor: "", tokenOutDenom: "", takerFee: "", liquidityCap: "" };
}

export const OsmosisPool: MessageFns<OsmosisPool> = {
  encode(message: OsmosisPool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.spreadFactor !== "") {
      writer.uint32(26).string(message.spreadFactor);
    }
    if (message.tokenOutDenom !== "") {
      writer.uint32(34).string(message.tokenOutDenom);
    }
    if (message.takerFee !== "") {
      writer.uint32(42).string(message.takerFee);
    }
    if (message.liquidityCap !== "") {
      writer.uint32(50).string(message.liquidityCap);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OsmosisPool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOsmosisPool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.spreadFactor = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tokenOutDenom = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.takerFee = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.liquidityCap = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OsmosisPool {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      spreadFactor: isSet(object.spreadFactor) ? globalThis.String(object.spreadFactor) : "",
      tokenOutDenom: isSet(object.tokenOutDenom) ? globalThis.String(object.tokenOutDenom) : "",
      takerFee: isSet(object.takerFee) ? globalThis.String(object.takerFee) : "",
      liquidityCap: isSet(object.liquidityCap) ? globalThis.String(object.liquidityCap) : "",
    };
  },

  toJSON(message: OsmosisPool): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.spreadFactor !== "") {
      obj.spreadFactor = message.spreadFactor;
    }
    if (message.tokenOutDenom !== "") {
      obj.tokenOutDenom = message.tokenOutDenom;
    }
    if (message.takerFee !== "") {
      obj.takerFee = message.takerFee;
    }
    if (message.liquidityCap !== "") {
      obj.liquidityCap = message.liquidityCap;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OsmosisPool>, I>>(base?: I): OsmosisPool {
    return OsmosisPool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OsmosisPool>, I>>(object: I): OsmosisPool {
    const message = createBaseOsmosisPool();
    message.id = object.id ?? 0;
    message.type = object.type ?? 0;
    message.spreadFactor = object.spreadFactor ?? "";
    message.tokenOutDenom = object.tokenOutDenom ?? "";
    message.takerFee = object.takerFee ?? "";
    message.liquidityCap = object.liquidityCap ?? "";
    return message;
  },
};

function createBaseLookupDenomRequest(): LookupDenomRequest {
  return { chainId: "", denom: "" };
}

export const LookupDenomRequest: MessageFns<LookupDenomRequest> = {
  encode(message: LookupDenomRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupDenomRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupDenomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupDenomRequest {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
    };
  },

  toJSON(message: LookupDenomRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LookupDenomRequest>, I>>(base?: I): LookupDenomRequest {
    return LookupDenomRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LookupDenomRequest>, I>>(object: I): LookupDenomRequest {
    const message = createBaseLookupDenomRequest();
    message.chainId = object.chainId ?? "";
    message.denom = object.denom ?? "";
    return message;
  },
};

function createBaseLookupDenomResponse(): LookupDenomResponse {
  return {
    found: false,
    chainDenom: "",
    baseDenom: "",
    originChain: "",
    isNative: false,
    ibcPath: "",
    availableOn: [],
  };
}

export const LookupDenomResponse: MessageFns<LookupDenomResponse> = {
  encode(message: LookupDenomResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.found !== false) {
      writer.uint32(8).bool(message.found);
    }
    if (message.chainDenom !== "") {
      writer.uint32(18).string(message.chainDenom);
    }
    if (message.baseDenom !== "") {
      writer.uint32(26).string(message.baseDenom);
    }
    if (message.originChain !== "") {
      writer.uint32(34).string(message.originChain);
    }
    if (message.isNative !== false) {
      writer.uint32(40).bool(message.isNative);
    }
    if (message.ibcPath !== "") {
      writer.uint32(50).string(message.ibcPath);
    }
    for (const v of message.availableOn) {
      ChainDenom.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupDenomResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupDenomResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainDenom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.baseDenom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.originChain = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isNative = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ibcPath = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.availableOn.push(ChainDenom.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupDenomResponse {
    return {
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
      chainDenom: isSet(object.chainDenom) ? globalThis.String(object.chainDenom) : "",
      baseDenom: isSet(object.baseDenom) ? globalThis.String(object.baseDenom) : "",
      originChain: isSet(object.originChain) ? globalThis.String(object.originChain) : "",
      isNative: isSet(object.isNative) ? globalThis.Boolean(object.isNative) : false,
      ibcPath: isSet(object.ibcPath) ? globalThis.String(object.ibcPath) : "",
      availableOn: globalThis.Array.isArray(object?.availableOn)
        ? object.availableOn.map((e: any) => ChainDenom.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LookupDenomResponse): unknown {
    const obj: any = {};
    if (message.found !== false) {
      obj.found = message.found;
    }
    if (message.chainDenom !== "") {
      obj.chainDenom = message.chainDenom;
    }
    if (message.baseDenom !== "") {
      obj.baseDenom = message.baseDenom;
    }
    if (message.originChain !== "") {
      obj.originChain = message.originChain;
    }
    if (message.isNative !== false) {
      obj.isNative = message.isNative;
    }
    if (message.ibcPath !== "") {
      obj.ibcPath = message.ibcPath;
    }
    if (message.availableOn?.length) {
      obj.availableOn = message.availableOn.map((e) => ChainDenom.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LookupDenomResponse>, I>>(base?: I): LookupDenomResponse {
    return LookupDenomResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LookupDenomResponse>, I>>(object: I): LookupDenomResponse {
    const message = createBaseLookupDenomResponse();
    message.found = object.found ?? false;
    message.chainDenom = object.chainDenom ?? "";
    message.baseDenom = object.baseDenom ?? "";
    message.originChain = object.originChain ?? "";
    message.isNative = object.isNative ?? false;
    message.ibcPath = object.ibcPath ?? "";
    message.availableOn = object.availableOn?.map((e) => ChainDenom.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChainDenom(): ChainDenom {
  return { chainId: "", chainName: "", denom: "", isNative: false };
}

export const ChainDenom: MessageFns<ChainDenom> = {
  encode(message: ChainDenom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.chainName !== "") {
      writer.uint32(18).string(message.chainName);
    }
    if (message.denom !== "") {
      writer.uint32(26).string(message.denom);
    }
    if (message.isNative !== false) {
      writer.uint32(32).bool(message.isNative);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainDenom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainDenom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isNative = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainDenom {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      chainName: isSet(object.chainName) ? globalThis.String(object.chainName) : "",
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      isNative: isSet(object.isNative) ? globalThis.Boolean(object.isNative) : false,
    };
  },

  toJSON(message: ChainDenom): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.chainName !== "") {
      obj.chainName = message.chainName;
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.isNative !== false) {
      obj.isNative = message.isNative;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainDenom>, I>>(base?: I): ChainDenom {
    return ChainDenom.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainDenom>, I>>(object: I): ChainDenom {
    const message = createBaseChainDenom();
    message.chainId = object.chainId ?? "";
    message.chainName = object.chainName ?? "";
    message.denom = object.denom ?? "";
    message.isNative = object.isNative ?? false;
    return message;
  },
};

function createBaseGetTokenDenomsRequest(): GetTokenDenomsRequest {
  return { baseDenom: "", originChain: "", onChainId: "" };
}

export const GetTokenDenomsRequest: MessageFns<GetTokenDenomsRequest> = {
  encode(message: GetTokenDenomsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseDenom !== "") {
      writer.uint32(10).string(message.baseDenom);
    }
    if (message.originChain !== "") {
      writer.uint32(18).string(message.originChain);
    }
    if (message.onChainId !== "") {
      writer.uint32(26).string(message.onChainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokenDenomsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokenDenomsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseDenom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.originChain = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.onChainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokenDenomsRequest {
    return {
      baseDenom: isSet(object.baseDenom) ? globalThis.String(object.baseDenom) : "",
      originChain: isSet(object.originChain) ? globalThis.String(object.originChain) : "",
      onChainId: isSet(object.onChainId) ? globalThis.String(object.onChainId) : "",
    };
  },

  toJSON(message: GetTokenDenomsRequest): unknown {
    const obj: any = {};
    if (message.baseDenom !== "") {
      obj.baseDenom = message.baseDenom;
    }
    if (message.originChain !== "") {
      obj.originChain = message.originChain;
    }
    if (message.onChainId !== "") {
      obj.onChainId = message.onChainId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokenDenomsRequest>, I>>(base?: I): GetTokenDenomsRequest {
    return GetTokenDenomsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokenDenomsRequest>, I>>(object: I): GetTokenDenomsRequest {
    const message = createBaseGetTokenDenomsRequest();
    message.baseDenom = object.baseDenom ?? "";
    message.originChain = object.originChain ?? "";
    message.onChainId = object.onChainId ?? "";
    return message;
  },
};

function createBaseGetTokenDenomsResponse(): GetTokenDenomsResponse {
  return { found: false, baseDenom: "", originChain: "", denoms: [] };
}

export const GetTokenDenomsResponse: MessageFns<GetTokenDenomsResponse> = {
  encode(message: GetTokenDenomsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.found !== false) {
      writer.uint32(8).bool(message.found);
    }
    if (message.baseDenom !== "") {
      writer.uint32(18).string(message.baseDenom);
    }
    if (message.originChain !== "") {
      writer.uint32(26).string(message.originChain);
    }
    for (const v of message.denoms) {
      ChainDenom.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokenDenomsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokenDenomsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseDenom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.originChain = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.denoms.push(ChainDenom.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokenDenomsResponse {
    return {
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
      baseDenom: isSet(object.baseDenom) ? globalThis.String(object.baseDenom) : "",
      originChain: isSet(object.originChain) ? globalThis.String(object.originChain) : "",
      denoms: globalThis.Array.isArray(object?.denoms) ? object.denoms.map((e: any) => ChainDenom.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetTokenDenomsResponse): unknown {
    const obj: any = {};
    if (message.found !== false) {
      obj.found = message.found;
    }
    if (message.baseDenom !== "") {
      obj.baseDenom = message.baseDenom;
    }
    if (message.originChain !== "") {
      obj.originChain = message.originChain;
    }
    if (message.denoms?.length) {
      obj.denoms = message.denoms.map((e) => ChainDenom.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokenDenomsResponse>, I>>(base?: I): GetTokenDenomsResponse {
    return GetTokenDenomsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokenDenomsResponse>, I>>(object: I): GetTokenDenomsResponse {
    const message = createBaseGetTokenDenomsResponse();
    message.found = object.found ?? false;
    message.baseDenom = object.baseDenom ?? "";
    message.originChain = object.originChain ?? "";
    message.denoms = object.denoms?.map((e) => ChainDenom.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetChainTokensRequest(): GetChainTokensRequest {
  return { chainId: "" };
}

export const GetChainTokensRequest: MessageFns<GetChainTokensRequest> = {
  encode(message: GetChainTokensRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChainTokensRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChainTokensRequest {
    return { chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "" };
  },

  toJSON(message: GetChainTokensRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChainTokensRequest>, I>>(base?: I): GetChainTokensRequest {
    return GetChainTokensRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChainTokensRequest>, I>>(object: I): GetChainTokensRequest {
    const message = createBaseGetChainTokensRequest();
    message.chainId = object.chainId ?? "";
    return message;
  },
};

function createBaseGetChainTokensResponse(): GetChainTokensResponse {
  return { chainId: "", chainName: "", nativeTokens: [], ibcTokens: [] };
}

export const GetChainTokensResponse: MessageFns<GetChainTokensResponse> = {
  encode(message: GetChainTokensResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.chainName !== "") {
      writer.uint32(18).string(message.chainName);
    }
    for (const v of message.nativeTokens) {
      TokenDetails.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.ibcTokens) {
      TokenDetails.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChainTokensResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainTokensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nativeTokens.push(TokenDetails.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ibcTokens.push(TokenDetails.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChainTokensResponse {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      chainName: isSet(object.chainName) ? globalThis.String(object.chainName) : "",
      nativeTokens: globalThis.Array.isArray(object?.nativeTokens)
        ? object.nativeTokens.map((e: any) => TokenDetails.fromJSON(e))
        : [],
      ibcTokens: globalThis.Array.isArray(object?.ibcTokens)
        ? object.ibcTokens.map((e: any) => TokenDetails.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetChainTokensResponse): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.chainName !== "") {
      obj.chainName = message.chainName;
    }
    if (message.nativeTokens?.length) {
      obj.nativeTokens = message.nativeTokens.map((e) => TokenDetails.toJSON(e));
    }
    if (message.ibcTokens?.length) {
      obj.ibcTokens = message.ibcTokens.map((e) => TokenDetails.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChainTokensResponse>, I>>(base?: I): GetChainTokensResponse {
    return GetChainTokensResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChainTokensResponse>, I>>(object: I): GetChainTokensResponse {
    const message = createBaseGetChainTokensResponse();
    message.chainId = object.chainId ?? "";
    message.chainName = object.chainName ?? "";
    message.nativeTokens = object.nativeTokens?.map((e) => TokenDetails.fromPartial(e)) || [];
    message.ibcTokens = object.ibcTokens?.map((e) => TokenDetails.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTokenDetails(): TokenDetails {
  return { denom: "", symbol: "", baseDenom: "", originChain: "", decimals: 0, isNative: false };
}

export const TokenDetails: MessageFns<TokenDetails> = {
  encode(message: TokenDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.baseDenom !== "") {
      writer.uint32(26).string(message.baseDenom);
    }
    if (message.originChain !== "") {
      writer.uint32(34).string(message.originChain);
    }
    if (message.decimals !== 0) {
      writer.uint32(40).int32(message.decimals);
    }
    if (message.isNative !== false) {
      writer.uint32(48).bool(message.isNative);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.baseDenom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.originChain = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.decimals = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isNative = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenDetails {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      baseDenom: isSet(object.baseDenom) ? globalThis.String(object.baseDenom) : "",
      originChain: isSet(object.originChain) ? globalThis.String(object.originChain) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      isNative: isSet(object.isNative) ? globalThis.Boolean(object.isNative) : false,
    };
  },

  toJSON(message: TokenDetails): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.baseDenom !== "") {
      obj.baseDenom = message.baseDenom;
    }
    if (message.originChain !== "") {
      obj.originChain = message.originChain;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.isNative !== false) {
      obj.isNative = message.isNative;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenDetails>, I>>(base?: I): TokenDetails {
    return TokenDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenDetails>, I>>(object: I): TokenDetails {
    const message = createBaseTokenDetails();
    message.denom = object.denom ?? "";
    message.symbol = object.symbol ?? "";
    message.baseDenom = object.baseDenom ?? "";
    message.originChain = object.originChain ?? "";
    message.decimals = object.decimals ?? 0;
    message.isNative = object.isNative ?? false;
    return message;
  },
};

function createBasePathfinderSupportedChainsResponse(): PathfinderSupportedChainsResponse {
  return { chainIds: [] };
}

export const PathfinderSupportedChainsResponse: MessageFns<PathfinderSupportedChainsResponse> = {
  encode(message: PathfinderSupportedChainsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.chainIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PathfinderSupportedChainsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePathfinderSupportedChainsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PathfinderSupportedChainsResponse {
    return {
      chainIds: globalThis.Array.isArray(object?.chainIds) ? object.chainIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: PathfinderSupportedChainsResponse): unknown {
    const obj: any = {};
    if (message.chainIds?.length) {
      obj.chainIds = message.chainIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PathfinderSupportedChainsResponse>, I>>(
    base?: I,
  ): PathfinderSupportedChainsResponse {
    return PathfinderSupportedChainsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PathfinderSupportedChainsResponse>, I>>(
    object: I,
  ): PathfinderSupportedChainsResponse {
    const message = createBasePathfinderSupportedChainsResponse();
    message.chainIds = object.chainIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseChainInfoRequest(): ChainInfoRequest {
  return { chainId: "", sortBySymbol: false };
}

export const ChainInfoRequest: MessageFns<ChainInfoRequest> = {
  encode(message: ChainInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.sortBySymbol !== false) {
      writer.uint32(16).bool(message.sortBySymbol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sortBySymbol = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainInfoRequest {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      sortBySymbol: isSet(object.sortBySymbol) ? globalThis.Boolean(object.sortBySymbol) : false,
    };
  },

  toJSON(message: ChainInfoRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.sortBySymbol !== false) {
      obj.sortBySymbol = message.sortBySymbol;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainInfoRequest>, I>>(base?: I): ChainInfoRequest {
    return ChainInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainInfoRequest>, I>>(object: I): ChainInfoRequest {
    const message = createBaseChainInfoRequest();
    message.chainId = object.chainId ?? "";
    message.sortBySymbol = object.sortBySymbol ?? false;
    return message;
  },
};

function createBaseChainInfoResponse(): ChainInfoResponse {
  return { chainInfo: undefined };
}

export const ChainInfoResponse: MessageFns<ChainInfoResponse> = {
  encode(message: ChainInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainInfo !== undefined) {
      ChainInfo.encode(message.chainInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainInfo = ChainInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainInfoResponse {
    return { chainInfo: isSet(object.chainInfo) ? ChainInfo.fromJSON(object.chainInfo) : undefined };
  },

  toJSON(message: ChainInfoResponse): unknown {
    const obj: any = {};
    if (message.chainInfo !== undefined) {
      obj.chainInfo = ChainInfo.toJSON(message.chainInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainInfoResponse>, I>>(base?: I): ChainInfoResponse {
    return ChainInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainInfoResponse>, I>>(object: I): ChainInfoResponse {
    const message = createBaseChainInfoResponse();
    message.chainInfo = (object.chainInfo !== undefined && object.chainInfo !== null)
      ? ChainInfo.fromPartial(object.chainInfo)
      : undefined;
    return message;
  },
};

function createBaseChainInfo(): ChainInfo {
  return { chainId: "", chainName: "", hasPfm: false, isBroker: false, routes: [] };
}

export const ChainInfo: MessageFns<ChainInfo> = {
  encode(message: ChainInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    if (message.chainName !== "") {
      writer.uint32(18).string(message.chainName);
    }
    if (message.hasPfm !== false) {
      writer.uint32(24).bool(message.hasPfm);
    }
    if (message.isBroker !== false) {
      writer.uint32(32).bool(message.isBroker);
    }
    for (const v of message.routes) {
      BasicRoute.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChainInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChainInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chainName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hasPfm = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isBroker = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.routes.push(BasicRoute.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChainInfo {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      chainName: isSet(object.chainName) ? globalThis.String(object.chainName) : "",
      hasPfm: isSet(object.hasPfm) ? globalThis.Boolean(object.hasPfm) : false,
      isBroker: isSet(object.isBroker) ? globalThis.Boolean(object.isBroker) : false,
      routes: globalThis.Array.isArray(object?.routes) ? object.routes.map((e: any) => BasicRoute.fromJSON(e)) : [],
    };
  },

  toJSON(message: ChainInfo): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.chainName !== "") {
      obj.chainName = message.chainName;
    }
    if (message.hasPfm !== false) {
      obj.hasPfm = message.hasPfm;
    }
    if (message.isBroker !== false) {
      obj.isBroker = message.isBroker;
    }
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => BasicRoute.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChainInfo>, I>>(base?: I): ChainInfo {
    return ChainInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChainInfo>, I>>(object: I): ChainInfo {
    const message = createBaseChainInfo();
    message.chainId = object.chainId ?? "";
    message.chainName = object.chainName ?? "";
    message.hasPfm = object.hasPfm ?? false;
    message.isBroker = object.isBroker ?? false;
    message.routes = object.routes?.map((e) => BasicRoute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTokenInfo(): TokenInfo {
  return { chainDenom: "", ibcDenom: "", baseDenom: "", originChain: "", decimals: 0, symbol: "" };
}

export const TokenInfo: MessageFns<TokenInfo> = {
  encode(message: TokenInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainDenom !== "") {
      writer.uint32(10).string(message.chainDenom);
    }
    if (message.ibcDenom !== "") {
      writer.uint32(18).string(message.ibcDenom);
    }
    if (message.baseDenom !== "") {
      writer.uint32(26).string(message.baseDenom);
    }
    if (message.originChain !== "") {
      writer.uint32(34).string(message.originChain);
    }
    if (message.decimals !== 0) {
      writer.uint32(40).int32(message.decimals);
    }
    if (message.symbol !== "") {
      writer.uint32(50).string(message.symbol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TokenInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTokenInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainDenom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ibcDenom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.baseDenom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.originChain = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.decimals = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TokenInfo {
    return {
      chainDenom: isSet(object.chainDenom) ? globalThis.String(object.chainDenom) : "",
      ibcDenom: isSet(object.ibcDenom) ? globalThis.String(object.ibcDenom) : "",
      baseDenom: isSet(object.baseDenom) ? globalThis.String(object.baseDenom) : "",
      originChain: isSet(object.originChain) ? globalThis.String(object.originChain) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
    };
  },

  toJSON(message: TokenInfo): unknown {
    const obj: any = {};
    if (message.chainDenom !== "") {
      obj.chainDenom = message.chainDenom;
    }
    if (message.ibcDenom !== "") {
      obj.ibcDenom = message.ibcDenom;
    }
    if (message.baseDenom !== "") {
      obj.baseDenom = message.baseDenom;
    }
    if (message.originChain !== "") {
      obj.originChain = message.originChain;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TokenInfo>, I>>(base?: I): TokenInfo {
    return TokenInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TokenInfo>, I>>(object: I): TokenInfo {
    const message = createBaseTokenInfo();
    message.chainDenom = object.chainDenom ?? "";
    message.ibcDenom = object.ibcDenom ?? "";
    message.baseDenom = object.baseDenom ?? "";
    message.originChain = object.originChain ?? "";
    message.decimals = object.decimals ?? 0;
    message.symbol = object.symbol ?? "";
    return message;
  },
};

function createBaseBasicRoute(): BasicRoute {
  return { toChain: "", toChainId: "", connectionId: "", channelId: "", portId: "", allowedTokens: {} };
}

export const BasicRoute: MessageFns<BasicRoute> = {
  encode(message: BasicRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.toChain !== "") {
      writer.uint32(10).string(message.toChain);
    }
    if (message.toChainId !== "") {
      writer.uint32(18).string(message.toChainId);
    }
    if (message.connectionId !== "") {
      writer.uint32(26).string(message.connectionId);
    }
    if (message.channelId !== "") {
      writer.uint32(34).string(message.channelId);
    }
    if (message.portId !== "") {
      writer.uint32(42).string(message.portId);
    }
    globalThis.Object.entries(message.allowedTokens).forEach(([key, value]: [string, TokenInfo]) => {
      BasicRoute_AllowedTokensEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.toChain = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toChainId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.channelId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.portId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = BasicRoute_AllowedTokensEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.allowedTokens[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasicRoute {
    return {
      toChain: isSet(object.toChain) ? globalThis.String(object.toChain) : "",
      toChainId: isSet(object.toChainId) ? globalThis.String(object.toChainId) : "",
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      portId: isSet(object.portId) ? globalThis.String(object.portId) : "",
      allowedTokens: isObject(object.allowedTokens)
        ? (globalThis.Object.entries(object.allowedTokens) as [string, any][]).reduce(
          (acc: { [key: string]: TokenInfo }, [key, value]: [string, any]) => {
            acc[key] = TokenInfo.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: BasicRoute): unknown {
    const obj: any = {};
    if (message.toChain !== "") {
      obj.toChain = message.toChain;
    }
    if (message.toChainId !== "") {
      obj.toChainId = message.toChainId;
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.portId !== "") {
      obj.portId = message.portId;
    }
    if (message.allowedTokens) {
      const entries = globalThis.Object.entries(message.allowedTokens) as [string, TokenInfo][];
      if (entries.length > 0) {
        obj.allowedTokens = {};
        entries.forEach(([k, v]) => {
          obj.allowedTokens[k] = TokenInfo.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasicRoute>, I>>(base?: I): BasicRoute {
    return BasicRoute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasicRoute>, I>>(object: I): BasicRoute {
    const message = createBaseBasicRoute();
    message.toChain = object.toChain ?? "";
    message.toChainId = object.toChainId ?? "";
    message.connectionId = object.connectionId ?? "";
    message.channelId = object.channelId ?? "";
    message.portId = object.portId ?? "";
    message.allowedTokens = (globalThis.Object.entries(object.allowedTokens ?? {}) as [string, TokenInfo][]).reduce(
      (acc: { [key: string]: TokenInfo }, [key, value]: [string, TokenInfo]) => {
        if (value !== undefined) {
          acc[key] = TokenInfo.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseBasicRoute_AllowedTokensEntry(): BasicRoute_AllowedTokensEntry {
  return { key: "", value: undefined };
}

export const BasicRoute_AllowedTokensEntry: MessageFns<BasicRoute_AllowedTokensEntry> = {
  encode(message: BasicRoute_AllowedTokensEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TokenInfo.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicRoute_AllowedTokensEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicRoute_AllowedTokensEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = TokenInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasicRoute_AllowedTokensEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TokenInfo.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BasicRoute_AllowedTokensEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TokenInfo.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasicRoute_AllowedTokensEntry>, I>>(base?: I): BasicRoute_AllowedTokensEntry {
    return BasicRoute_AllowedTokensEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasicRoute_AllowedTokensEntry>, I>>(
    object: I,
  ): BasicRoute_AllowedTokensEntry {
    const message = createBaseBasicRoute_AllowedTokensEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TokenInfo.fromPartial(object.value)
      : undefined;
    return message;
  },
};

/** PathfinderService provides route discovery and validation for IBC transfers and swaps */
export interface PathfinderService {
  /**
   * FindPath finds and validates a route between two chains
   * Supports human-readable denoms (e.g., "uatone") or IBC denoms
   */
  FindPath(request: FindPathRequest): Promise<FindPathResponse>;
  /**
   * LookupDenom resolves denom information on a specific chain
   * Accepts human-readable base denoms or IBC denom hashes
   */
  LookupDenom(request: LookupDenomRequest): Promise<LookupDenomResponse>;
  /**
   * GetTokenDenoms returns all IBC denoms for a token across supported chains
   * Use this to discover what denom a token has on different chains
   */
  GetTokenDenoms(request: GetTokenDenomsRequest): Promise<GetTokenDenomsResponse>;
  /** GetChainInfo returns information about a specific chain */
  GetChainInfo(request: ChainInfoRequest): Promise<ChainInfoResponse>;
  /** GetPathfinderSupportedChains returns a list of supported chains */
  GetPathfinderSupportedChains(request: Empty): Promise<PathfinderSupportedChainsResponse>;
  /**
   * GetChainTokens returns all tokens available on a specific chain
   * Includes both native tokens and IBC tokens with their denoms
   */
  GetChainTokens(request: GetChainTokensRequest): Promise<GetChainTokensResponse>;
}

export const PathfinderServiceServiceName = "rpc.v1.PathfinderService";
export class PathfinderServiceClientImpl implements PathfinderService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || PathfinderServiceServiceName;
    this.rpc = rpc;
    this.FindPath = this.FindPath.bind(this);
    this.LookupDenom = this.LookupDenom.bind(this);
    this.GetTokenDenoms = this.GetTokenDenoms.bind(this);
    this.GetChainInfo = this.GetChainInfo.bind(this);
    this.GetPathfinderSupportedChains = this.GetPathfinderSupportedChains.bind(this);
    this.GetChainTokens = this.GetChainTokens.bind(this);
  }
  FindPath(request: FindPathRequest): Promise<FindPathResponse> {
    const data = FindPathRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FindPath", data);
    return promise.then((data) => FindPathResponse.decode(new BinaryReader(data)));
  }

  LookupDenom(request: LookupDenomRequest): Promise<LookupDenomResponse> {
    const data = LookupDenomRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LookupDenom", data);
    return promise.then((data) => LookupDenomResponse.decode(new BinaryReader(data)));
  }

  GetTokenDenoms(request: GetTokenDenomsRequest): Promise<GetTokenDenomsResponse> {
    const data = GetTokenDenomsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTokenDenoms", data);
    return promise.then((data) => GetTokenDenomsResponse.decode(new BinaryReader(data)));
  }

  GetChainInfo(request: ChainInfoRequest): Promise<ChainInfoResponse> {
    const data = ChainInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetChainInfo", data);
    return promise.then((data) => ChainInfoResponse.decode(new BinaryReader(data)));
  }

  GetPathfinderSupportedChains(request: Empty): Promise<PathfinderSupportedChainsResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPathfinderSupportedChains", data);
    return promise.then((data) => PathfinderSupportedChainsResponse.decode(new BinaryReader(data)));
  }

  GetChainTokens(request: GetChainTokensRequest): Promise<GetChainTokensResponse> {
    const data = GetChainTokensRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetChainTokens", data);
    return promise.then((data) => GetChainTokensResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
