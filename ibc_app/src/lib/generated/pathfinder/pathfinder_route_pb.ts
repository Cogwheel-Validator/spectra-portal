// @generated by protoc-gen-es v2.10.2 with parameter "target=ts"
// @generated from file pathfinder_route.proto (package rpc.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_buf_validate_validate } from "./buf/validate/validate_pb";
import type { EmptySchema } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file pathfinder_route.proto.
 */
export const file_pathfinder_route: GenFile = /*@__PURE__*/
  fileDesc("ChZwYXRoZmluZGVyX3JvdXRlLnByb3RvEgZycGMudjEitgIKD0ZpbmRQYXRoUmVxdWVzdBIaCgpjaGFpbl9mcm9tGAEgASgJQga6SAPIAQESJwoQdG9rZW5fZnJvbV9kZW5vbRgCIAEoCUINukgKyAEBcgUQARiAARIZCglhbW91bnRfaW4YAyABKAlCBrpIA8gBARIYCghjaGFpbl90bxgEIAEoCUIGukgDyAEBEiAKDnRva2VuX3RvX2Rlbm9tGAUgASgJQgi6SAVyAxiAARIkCg5zZW5kZXJfYWRkcmVzcxgGIAEoCUIMukgJyAEBcgQQJhhEEiYKEHJlY2VpdmVyX2FkZHJlc3MYByABKAlCDLpICcgBAXIEECYYRBIUCgxzaW5nbGVfcm91dGUYCCABKAgSIwoMc2xpcHBhZ2VfYnBzGAkgASgNQg26SArIAQAqBRiQTiAAIsUBChBGaW5kUGF0aFJlc3BvbnNlEg8KB3N1Y2Nlc3MYASABKAgSFQoNZXJyb3JfbWVzc2FnZRgCIAEoCRIlCgZkaXJlY3QYAyABKAsyEy5ycGMudjEuRGlyZWN0Um91dGVIABIpCghpbmRpcmVjdBgEIAEoCzIVLnJwYy52MS5JbmRpcmVjdFJvdXRlSAASLgoLYnJva2VyX3N3YXAYBSABKAsyFy5ycGMudjEuQnJva2VyU3dhcFJvdXRlSABCBwoFcm91dGUiLwoLRGlyZWN0Um91dGUSIAoIdHJhbnNmZXIYASABKAsyDi5ycGMudjEuSUJDTGVnInwKDUluZGlyZWN0Um91dGUSDAoEcGF0aBgBIAMoCRIcCgRsZWdzGAIgAygLMg4ucnBjLnYxLklCQ0xlZxIUCgxzdXBwb3J0c19wZm0YAyABKAgSFwoPcGZtX3N0YXJ0X2NoYWluGAQgASgJEhAKCHBmbV9tZW1vGAUgASgJItsBCg9Ccm9rZXJTd2FwUm91dGUSDAoEcGF0aBgBIAMoCRIjCgtpbmJvdW5kX2xlZxgCIAEoCzIOLnJwYy52MS5JQkNMZWcSHwoEc3dhcBgDIAEoCzIRLnJwYy52MS5Td2FwUXVvdGUSJQoNb3V0Ym91bmRfbGVncxgEIAMoCzIOLnJwYy52MS5JQkNMZWcSHQoVb3V0Ym91bmRfc3VwcG9ydHNfcGZtGAUgASgIEi4KCWV4ZWN1dGlvbhgGIAEoCzIbLnJwYy52MS5Ccm9rZXJFeGVjdXRpb25EYXRhIpUBChNCcm9rZXJFeGVjdXRpb25EYXRhEgwKBG1lbW8YASABKAkSFAoMaWJjX3JlY2VpdmVyGAIgASgJEhcKD3JlY292ZXJfYWRkcmVzcxgDIAEoCRIZChFtaW5fb3V0cHV0X2Ftb3VudBgEIAEoCRIRCgl1c2VzX3dhc20YBSABKAgSEwoLZGVzY3JpcHRpb24YBiABKAkiggEKBklCQ0xlZxISCgpmcm9tX2NoYWluGAEgASgJEhAKCHRvX2NoYWluGAIgASgJEg8KB2NoYW5uZWwYAyABKAkSDAoEcG9ydBgEIAEoCRIjCgV0b2tlbhgFIAEoCzIULnJwYy52MS5Ub2tlbk1hcHBpbmcSDgoGYW1vdW50GAYgASgJImAKDFRva2VuTWFwcGluZxITCgtjaGFpbl9kZW5vbRgBIAEoCRISCgpiYXNlX2Rlbm9tGAIgASgJEhQKDG9yaWdpbl9jaGFpbhgDIAEoCRIRCglpc19uYXRpdmUYBCABKAgihgIKCVN3YXBRdW90ZRIOCgZicm9rZXIYASABKAkSJgoIdG9rZW5faW4YAiABKAsyFC5ycGMudjEuVG9rZW5NYXBwaW5nEicKCXRva2VuX291dBgDIAEoCzIULnJwYy52MS5Ub2tlbk1hcHBpbmcSEQoJYW1vdW50X2luGAQgASgJEhIKCmFtb3VudF9vdXQYBSABKAkSFAoMcHJpY2VfaW1wYWN0GAYgASgJEhUKDWVmZmVjdGl2ZV9mZWUYByABKAkSNgoSb3Ntb3Npc19yb3V0ZV9kYXRhGAggASgLMhgucnBjLnYxLk9zbW9zaXNSb3V0ZURhdGFIAEIMCgpyb3V0ZV9kYXRhIm8KEE9zbW9zaXNSb3V0ZURhdGESJAoGcm91dGVzGAEgAygLMhQucnBjLnYxLk9zbW9zaXNSb3V0ZRIVCg1saXF1aWRpdHlfY2FwGAIgASgJEh4KFmxpcXVpZGl0eV9jYXBfb3ZlcmZsb3cYAyABKAgibgoMT3Ntb3Npc1JvdXRlEiIKBXBvb2xzGAEgAygLMhMucnBjLnYxLk9zbW9zaXNQb29sEhMKC2hhc19jd19wb29sGAIgASgIEhIKCm91dF9hbW91bnQYAyABKAkSEQoJaW5fYW1vdW50GAQgASgJIoEBCgtPc21vc2lzUG9vbBIKCgJpZBgBIAEoBRIMCgR0eXBlGAIgASgFEhUKDXNwcmVhZF9mYWN0b3IYAyABKAkSFwoPdG9rZW5fb3V0X2Rlbm9tGAQgASgJEhEKCXRha2VyX2ZlZRgFIAEoCRIVCg1saXF1aWRpdHlfY2FwGAYgASgJIkwKEkxvb2t1cERlbm9tUmVxdWVzdBIYCghjaGFpbl9pZBgBIAEoCUIGukgDyAEBEhwKBWRlbm9tGAIgASgJQg26SArIAQFyBRABGIABIrIBChNMb29rdXBEZW5vbVJlc3BvbnNlEg0KBWZvdW5kGAEgASgIEhMKC2NoYWluX2Rlbm9tGAIgASgJEhIKCmJhc2VfZGVub20YAyABKAkSFAoMb3JpZ2luX2NoYWluGAQgASgJEhEKCWlzX25hdGl2ZRgFIAEoCBIQCghpYmNfcGF0aBgGIAEoCRIoCgxhdmFpbGFibGVfb24YByADKAsyEi5ycGMudjEuQ2hhaW5EZW5vbSJUCgpDaGFpbkRlbm9tEhAKCGNoYWluX2lkGAEgASgJEhIKCmNoYWluX25hbWUYAiABKAkSDQoFZGVub20YAyABKAkSEQoJaXNfbmF0aXZlGAQgASgIImYKFUdldFRva2VuRGVub21zUmVxdWVzdBIaCgpiYXNlX2Rlbm9tGAEgASgJQga6SAPIAQESHAoMb3JpZ2luX2NoYWluGAIgASgJQga6SAPIAQESEwoLb25fY2hhaW5faWQYAyABKAkidQoWR2V0VG9rZW5EZW5vbXNSZXNwb25zZRINCgVmb3VuZBgBIAEoCBISCgpiYXNlX2Rlbm9tGAIgASgJEhQKDG9yaWdpbl9jaGFpbhgDIAEoCRIiCgZkZW5vbXMYBCADKAsyEi5ycGMudjEuQ2hhaW5EZW5vbSIxChVHZXRDaGFpblRva2Vuc1JlcXVlc3QSGAoIY2hhaW5faWQYASABKAlCBrpIA8gBASKVAQoWR2V0Q2hhaW5Ub2tlbnNSZXNwb25zZRIQCghjaGFpbl9pZBgBIAEoCRISCgpjaGFpbl9uYW1lGAIgASgJEisKDW5hdGl2ZV90b2tlbnMYAyADKAsyFC5ycGMudjEuVG9rZW5EZXRhaWxzEigKCmliY190b2tlbnMYBCADKAsyFC5ycGMudjEuVG9rZW5EZXRhaWxzInwKDFRva2VuRGV0YWlscxINCgVkZW5vbRgBIAEoCRIOCgZzeW1ib2wYAiABKAkSEgoKYmFzZV9kZW5vbRgDIAEoCRIUCgxvcmlnaW5fY2hhaW4YBCABKAkSEAoIZGVjaW1hbHMYBSABKAUSEQoJaXNfbmF0aXZlGAYgASgIIj4KIVBhdGhmaW5kZXJTdXBwb3J0ZWRDaGFpbnNSZXNwb25zZRIZCgljaGFpbl9pZHMYASADKAlCBrpIA8gBASJEChBDaGFpbkluZm9SZXF1ZXN0EhgKCGNoYWluX2lkGAEgASgJQga6SAPIAQESFgoOc29ydF9ieV9zeW1ib2wYAiABKAgiOgoRQ2hhaW5JbmZvUmVzcG9uc2USJQoKY2hhaW5faW5mbxgBIAEoCzIRLnJwYy52MS5DaGFpbkluZm8ieQoJQ2hhaW5JbmZvEhAKCGNoYWluX2lkGAEgASgJEhIKCmNoYWluX25hbWUYAiABKAkSDwoHaGFzX3BmbRgDIAEoCBIRCglpc19icm9rZXIYBCABKAgSIgoGcm91dGVzGAUgAygLMhIucnBjLnYxLkJhc2ljUm91dGUifwoJVG9rZW5JbmZvEhMKC2NoYWluX2Rlbm9tGAEgASgJEhEKCWliY19kZW5vbRgCIAEoCRISCgpiYXNlX2Rlbm9tGAMgASgJEhQKDG9yaWdpbl9jaGFpbhgEIAEoCRIQCghkZWNpbWFscxgFIAEoBRIOCgZzeW1ib2wYBiABKAki9wEKCkJhc2ljUm91dGUSEAoIdG9fY2hhaW4YASABKAkSEwoLdG9fY2hhaW5faWQYAiABKAkSFQoNY29ubmVjdGlvbl9pZBgDIAEoCRISCgpjaGFubmVsX2lkGAQgASgJEg8KB3BvcnRfaWQYBSABKAkSPQoOYWxsb3dlZF90b2tlbnMYBiADKAsyJS5ycGMudjEuQmFzaWNSb3V0ZS5BbGxvd2VkVG9rZW5zRW50cnkaRwoSQWxsb3dlZFRva2Vuc0VudHJ5EgsKA2tleRgBIAEoCRIgCgV2YWx1ZRgCIAEoCzIRLnJwYy52MS5Ub2tlbkluZm86AjgBMoIEChFQYXRoZmluZGVyU2VydmljZRJCCghGaW5kUGF0aBIXLnJwYy52MS5GaW5kUGF0aFJlcXVlc3QaGC5ycGMudjEuRmluZFBhdGhSZXNwb25zZSIDkAIBEksKC0xvb2t1cERlbm9tEhoucnBjLnYxLkxvb2t1cERlbm9tUmVxdWVzdBobLnJwYy52MS5Mb29rdXBEZW5vbVJlc3BvbnNlIgOQAgESVAoOR2V0VG9rZW5EZW5vbXMSHS5ycGMudjEuR2V0VG9rZW5EZW5vbXNSZXF1ZXN0Gh4ucnBjLnYxLkdldFRva2VuRGVub21zUmVzcG9uc2UiA5ACARJICgxHZXRDaGFpbkluZm8SGC5ycGMudjEuQ2hhaW5JbmZvUmVxdWVzdBoZLnJwYy52MS5DaGFpbkluZm9SZXNwb25zZSIDkAIBEmYKHEdldFBhdGhmaW5kZXJTdXBwb3J0ZWRDaGFpbnMSFi5nb29nbGUucHJvdG9idWYuRW1wdHkaKS5ycGMudjEuUGF0aGZpbmRlclN1cHBvcnRlZENoYWluc1Jlc3BvbnNlIgOQAgESVAoOR2V0Q2hhaW5Ub2tlbnMSHS5ycGMudjEuR2V0Q2hhaW5Ub2tlbnNSZXF1ZXN0Gh4ucnBjLnYxLkdldENoYWluVG9rZW5zUmVzcG9uc2UiA5ACAUJBWj9naXRodWIuY29tL0NvZ3doZWVsLVZhbGlkYXRvci9zcGVjdHJhLWliYy1odWIvcGF0aGZpbmRlci9ycGMvdjFiBnByb3RvMw", [file_buf_validate_validate, file_google_protobuf_empty]);

/**
 * FindPathRequest - Find a route between chains
 *
 * For token_from_denom and token_to_denom, you can use:
 * - Human-readable denom (e.g., "uatone", "uosmo", "ustars")
 * - Full IBC denom (e.g., "ibc/ABC123...")
 *
 * The pathfinder will automatically resolve human-readable denoms.
 * If token_to_denom is empty, the pathfinder assumes you want the same token
 * on the destination chain (useful for bridging without swapping).
 *
 * @generated from message rpc.v1.FindPathRequest
 */
export type FindPathRequest = Message<"rpc.v1.FindPathRequest"> & {
  /**
   * Source chain ID (e.g., "osmosis-1", "atomone-1")
   *
   * @generated from field: string chain_from = 1;
   */
  chainFrom: string;

  /**
   * Token denom on source chain - can be human-readable (e.g., "uatone") 
   * or IBC denom (e.g., "ibc/...")
   *
   * @generated from field: string token_from_denom = 2;
   */
  tokenFromDenom: string;

  /**
   * Amount to transfer/swap (in base units)
   *
   * @generated from field: string amount_in = 3;
   */
  amountIn: string;

  /**
   * Destination chain ID
   *
   * @generated from field: string chain_to = 4;
   */
  chainTo: string;

  /**
   * Token denom you want to receive on destination chain
   * Can be human-readable (e.g., "uosmo") or IBC denom
   * If empty, assumes same token as token_from (bridging without swap)
   *
   * @generated from field: string token_to_denom = 5;
   */
  tokenToDenom: string;

  /**
   * Sender address on source chain
   *
   * @generated from field: string sender_address = 6;
   */
  senderAddress: string;

  /**
   * Receiver address on destination chain
   *
   * @generated from field: string receiver_address = 7;
   */
  receiverAddress: string;

  /**
   * If true, only return a single route, if false, return all possible routes
   *
   * @generated from field: bool single_route = 8;
   */
  singleRoute: boolean;

  /**
   * Slippage in basis points (e.g., 100 = 1%, 1000 = 10%)
   * Must be less than 10000
   *
   * @generated from field: uint32 slippage_bps = 9;
   */
  slippageBps: number;
};

/**
 * Describes the message rpc.v1.FindPathRequest.
 * Use `create(FindPathRequestSchema)` to create a new message.
 */
export const FindPathRequestSchema: GenMessage<FindPathRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 0);

/**
 * @generated from message rpc.v1.FindPathResponse
 */
export type FindPathResponse = Message<"rpc.v1.FindPathResponse"> & {
  /**
   * @generated from field: bool success = 1;
   */
  success: boolean;

  /**
   * @generated from field: string error_message = 2;
   */
  errorMessage: string;

  /**
   * @generated from oneof rpc.v1.FindPathResponse.route
   */
  route: {
    /**
     * @generated from field: rpc.v1.DirectRoute direct = 3;
     */
    value: DirectRoute;
    case: "direct";
  } | {
    /**
     * @generated from field: rpc.v1.IndirectRoute indirect = 4;
     */
    value: IndirectRoute;
    case: "indirect";
  } | {
    /**
     * @generated from field: rpc.v1.BrokerSwapRoute broker_swap = 5;
     */
    value: BrokerSwapRoute;
    case: "brokerSwap";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message rpc.v1.FindPathResponse.
 * Use `create(FindPathResponseSchema)` to create a new message.
 */
export const FindPathResponseSchema: GenMessage<FindPathResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 1);

/**
 * @generated from message rpc.v1.DirectRoute
 */
export type DirectRoute = Message<"rpc.v1.DirectRoute"> & {
  /**
   * @generated from field: rpc.v1.IBCLeg transfer = 1;
   */
  transfer?: IBCLeg;
};

/**
 * Describes the message rpc.v1.DirectRoute.
 * Use `create(DirectRouteSchema)` to create a new message.
 */
export const DirectRouteSchema: GenMessage<DirectRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 2);

/**
 * @generated from message rpc.v1.IndirectRoute
 */
export type IndirectRoute = Message<"rpc.v1.IndirectRoute"> & {
  /**
   * @generated from field: repeated string path = 1;
   */
  path: string[];

  /**
   * @generated from field: repeated rpc.v1.IBCLeg legs = 2;
   */
  legs: IBCLeg[];

  /**
   * @generated from field: bool supports_pfm = 3;
   */
  supportsPfm: boolean;

  /**
   * @generated from field: string pfm_start_chain = 4;
   */
  pfmStartChain: string;

  /**
   * @generated from field: string pfm_memo = 5;
   */
  pfmMemo: string;
};

/**
 * Describes the message rpc.v1.IndirectRoute.
 * Use `create(IndirectRouteSchema)` to create a new message.
 */
export const IndirectRouteSchema: GenMessage<IndirectRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 3);

/**
 * BrokerSwapRoute represents a route involving a swap on a broker chain.
 * Supports various scenarios:
 * - Same-chain swap: inbound_leg absent, outbound_legs=[] (e.g., osmosis ATOM -> osmosis OSMO)
 * - Swap from broker: inbound_leg absent (e.g., osmosis USDC -> juno JUNO)
 * - Standard 3-chain: inbound_leg set, len(outbound_legs)=1
 * - Multi-hop outbound: inbound_leg set, len(outbound_legs)>1 (e.g., cosmos ATOM -> swap -> noble -> juno)
 *
 * @generated from message rpc.v1.BrokerSwapRoute
 */
export type BrokerSwapRoute = Message<"rpc.v1.BrokerSwapRoute"> & {
  /**
   * All chain IDs in order
   *
   * @generated from field: repeated string path = 1;
   */
  path: string[];

  /**
   * IBC transfer to reach broker (absent if starting from broker)
   *
   * @generated from field: rpc.v1.IBCLeg inbound_leg = 2;
   */
  inboundLeg?: IBCLeg;

  /**
   * The swap operation on the broker chain
   *
   * @generated from field: rpc.v1.SwapQuote swap = 3;
   */
  swap?: SwapQuote;

  /**
   * IBC transfers after swap (empty if destination is broker)
   * Can be multiple for multi-hop forwarding via PFM
   *
   * @generated from field: repeated rpc.v1.IBCLeg outbound_legs = 4;
   */
  outboundLegs: IBCLeg[];

  /**
   * Can use PFM for outbound legs
   *
   * @generated from field: bool outbound_supports_pfm = 5;
   */
  outboundSupportsPfm: boolean;

  /**
   * Execution data for building transactions
   *
   * @generated from field: rpc.v1.BrokerExecutionData execution = 6;
   */
  execution?: BrokerExecutionData;
};

/**
 * Describes the message rpc.v1.BrokerSwapRoute.
 * Use `create(BrokerSwapRouteSchema)` to create a new message.
 */
export const BrokerSwapRouteSchema: GenMessage<BrokerSwapRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 4);

/**
 * BrokerExecutionData contains ready-to-use transaction data
 *
 * @generated from message rpc.v1.BrokerExecutionData
 */
export type BrokerExecutionData = Message<"rpc.v1.BrokerExecutionData"> & {
  /**
   * The IBC memo to use with MsgTransfer (contains wasm swap_and_action)
   *
   * @generated from field: string memo = 1;
   */
  memo: string;

  /**
   * Receiver address for MsgTransfer (the ibc-hooks contract)
   *
   * @generated from field: string ibc_receiver = 2;
   */
  ibcReceiver: string;

  /**
   * Recovery address on broker chain (where funds go if swap/forward fails)
   *
   * @generated from field: string recover_address = 3;
   */
  recoverAddress: string;

  /**
   * Minimum output amount after slippage (1% default)
   *
   * @generated from field: string min_output_amount = 4;
   */
  minOutputAmount: string;

  /**
   * True if using wasm ibc-hooks (vs simple PFM)
   *
   * @generated from field: bool uses_wasm = 5;
   */
  usesWasm: boolean;

  /**
   * Human-readable description
   *
   * @generated from field: string description = 6;
   */
  description: string;
};

/**
 * Describes the message rpc.v1.BrokerExecutionData.
 * Use `create(BrokerExecutionDataSchema)` to create a new message.
 */
export const BrokerExecutionDataSchema: GenMessage<BrokerExecutionData> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 5);

/**
 * @generated from message rpc.v1.IBCLeg
 */
export type IBCLeg = Message<"rpc.v1.IBCLeg"> & {
  /**
   * @generated from field: string from_chain = 1;
   */
  fromChain: string;

  /**
   * @generated from field: string to_chain = 2;
   */
  toChain: string;

  /**
   * @generated from field: string channel = 3;
   */
  channel: string;

  /**
   * @generated from field: string port = 4;
   */
  port: string;

  /**
   * @generated from field: rpc.v1.TokenMapping token = 5;
   */
  token?: TokenMapping;

  /**
   * @generated from field: string amount = 6;
   */
  amount: string;
};

/**
 * Describes the message rpc.v1.IBCLeg.
 * Use `create(IBCLegSchema)` to create a new message.
 */
export const IBCLegSchema: GenMessage<IBCLeg> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 6);

/**
 * @generated from message rpc.v1.TokenMapping
 */
export type TokenMapping = Message<"rpc.v1.TokenMapping"> & {
  /**
   * The denom as it appears on the current chain (native or IBC)
   *
   * @generated from field: string chain_denom = 1;
   */
  chainDenom: string;

  /**
   * The base/native denom on the token's origin chain
   *
   * @generated from field: string base_denom = 2;
   */
  baseDenom: string;

  /**
   * The chain ID where this token is native
   *
   * @generated from field: string origin_chain = 3;
   */
  originChain: string;

  /**
   * True if this is the token's native chain
   *
   * @generated from field: bool is_native = 4;
   */
  isNative: boolean;
};

/**
 * Describes the message rpc.v1.TokenMapping.
 * Use `create(TokenMappingSchema)` to create a new message.
 */
export const TokenMappingSchema: GenMessage<TokenMapping> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 7);

/**
 * SwapQuote with broker-specific route data
 *
 * @generated from message rpc.v1.SwapQuote
 */
export type SwapQuote = Message<"rpc.v1.SwapQuote"> & {
  /**
   * @generated from field: string broker = 1;
   */
  broker: string;

  /**
   * @generated from field: rpc.v1.TokenMapping token_in = 2;
   */
  tokenIn?: TokenMapping;

  /**
   * @generated from field: rpc.v1.TokenMapping token_out = 3;
   */
  tokenOut?: TokenMapping;

  /**
   * @generated from field: string amount_in = 4;
   */
  amountIn: string;

  /**
   * @generated from field: string amount_out = 5;
   */
  amountOut: string;

  /**
   * @generated from field: string price_impact = 6;
   */
  priceImpact: string;

  /**
   * @generated from field: string effective_fee = 7;
   */
  effectiveFee: string;

  /**
   * Broker-specific route data using oneof for type safety
   *
   * @generated from oneof rpc.v1.SwapQuote.route_data
   */
  routeData: {
    /**
     * Future brokers can be added here without breaking existing clients
     *
     * @generated from field: rpc.v1.OsmosisRouteData osmosis_route_data = 8;
     */
    value: OsmosisRouteData;
    case: "osmosisRouteData";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message rpc.v1.SwapQuote.
 * Use `create(SwapQuoteSchema)` to create a new message.
 */
export const SwapQuoteSchema: GenMessage<SwapQuote> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 8);

/**
 * Osmosis-specific route data (from SQS API)
 *
 * @generated from message rpc.v1.OsmosisRouteData
 */
export type OsmosisRouteData = Message<"rpc.v1.OsmosisRouteData"> & {
  /**
   * @generated from field: repeated rpc.v1.OsmosisRoute routes = 1;
   */
  routes: OsmosisRoute[];

  /**
   * @generated from field: string liquidity_cap = 2;
   */
  liquidityCap: string;

  /**
   * @generated from field: bool liquidity_cap_overflow = 3;
   */
  liquidityCapOverflow: boolean;
};

/**
 * Describes the message rpc.v1.OsmosisRouteData.
 * Use `create(OsmosisRouteDataSchema)` to create a new message.
 */
export const OsmosisRouteDataSchema: GenMessage<OsmosisRouteData> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 9);

/**
 * @generated from message rpc.v1.OsmosisRoute
 */
export type OsmosisRoute = Message<"rpc.v1.OsmosisRoute"> & {
  /**
   * @generated from field: repeated rpc.v1.OsmosisPool pools = 1;
   */
  pools: OsmosisPool[];

  /**
   * @generated from field: bool has_cw_pool = 2;
   */
  hasCwPool: boolean;

  /**
   * @generated from field: string out_amount = 3;
   */
  outAmount: string;

  /**
   * @generated from field: string in_amount = 4;
   */
  inAmount: string;
};

/**
 * Describes the message rpc.v1.OsmosisRoute.
 * Use `create(OsmosisRouteSchema)` to create a new message.
 */
export const OsmosisRouteSchema: GenMessage<OsmosisRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 10);

/**
 * @generated from message rpc.v1.OsmosisPool
 */
export type OsmosisPool = Message<"rpc.v1.OsmosisPool"> & {
  /**
   * @generated from field: int32 id = 1;
   */
  id: number;

  /**
   * @generated from field: int32 type = 2;
   */
  type: number;

  /**
   * @generated from field: string spread_factor = 3;
   */
  spreadFactor: string;

  /**
   * @generated from field: string token_out_denom = 4;
   */
  tokenOutDenom: string;

  /**
   * @generated from field: string taker_fee = 5;
   */
  takerFee: string;

  /**
   * @generated from field: string liquidity_cap = 6;
   */
  liquidityCap: string;
};

/**
 * Describes the message rpc.v1.OsmosisPool.
 * Use `create(OsmosisPoolSchema)` to create a new message.
 */
export const OsmosisPoolSchema: GenMessage<OsmosisPool> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 11);

/**
 * LookupDenomRequest - Resolve token information
 * Accepts either:
 * - Human-readable denom (e.g., "uatone", "uosmo")
 * - IBC denom (e.g., "ibc/ABC123...")
 *
 * @generated from message rpc.v1.LookupDenomRequest
 */
export type LookupDenomRequest = Message<"rpc.v1.LookupDenomRequest"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: string denom = 2;
   */
  denom: string;
};

/**
 * Describes the message rpc.v1.LookupDenomRequest.
 * Use `create(LookupDenomRequestSchema)` to create a new message.
 */
export const LookupDenomRequestSchema: GenMessage<LookupDenomRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 12);

/**
 * @generated from message rpc.v1.LookupDenomResponse
 */
export type LookupDenomResponse = Message<"rpc.v1.LookupDenomResponse"> & {
  /**
   * @generated from field: bool found = 1;
   */
  found: boolean;

  /**
   * The denom as it appears on this chain
   *
   * @generated from field: string chain_denom = 2;
   */
  chainDenom: string;

  /**
   * The base/native denom
   *
   * @generated from field: string base_denom = 3;
   */
  baseDenom: string;

  /**
   * Where this token is native
   *
   * @generated from field: string origin_chain = 4;
   */
  originChain: string;

  /**
   * True if this is the token's native chain
   *
   * @generated from field: bool is_native = 5;
   */
  isNative: boolean;

  /**
   * IBC path if this is an IBC token (e.g., "transfer/channel-75")
   *
   * @generated from field: string ibc_path = 6;
   */
  ibcPath: string;

  /**
   * Denoms on other chains where this token is available
   *
   * @generated from field: repeated rpc.v1.ChainDenom available_on = 7;
   */
  availableOn: ChainDenom[];
};

/**
 * Describes the message rpc.v1.LookupDenomResponse.
 * Use `create(LookupDenomResponseSchema)` to create a new message.
 */
export const LookupDenomResponseSchema: GenMessage<LookupDenomResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 13);

/**
 * ChainDenom represents a token's denom on a specific chain
 *
 * @generated from message rpc.v1.ChainDenom
 */
export type ChainDenom = Message<"rpc.v1.ChainDenom"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: string chain_name = 2;
   */
  chainName: string;

  /**
   * @generated from field: string denom = 3;
   */
  denom: string;

  /**
   * @generated from field: bool is_native = 4;
   */
  isNative: boolean;
};

/**
 * Describes the message rpc.v1.ChainDenom.
 * Use `create(ChainDenomSchema)` to create a new message.
 */
export const ChainDenomSchema: GenMessage<ChainDenom> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 14);

/**
 * GetTokenDenomsRequest - Get all denoms for a token across chains
 * Use this to discover what denom a token has on different chains
 *
 * @generated from message rpc.v1.GetTokenDenomsRequest
 */
export type GetTokenDenomsRequest = Message<"rpc.v1.GetTokenDenomsRequest"> & {
  /**
   * The base denom (e.g., "uatone", "uosmo", "ustars")
   *
   * @generated from field: string base_denom = 1;
   */
  baseDenom: string;

  /**
   * The chain where this token is native (e.g., "atomone-1", "osmosis-1")
   *
   * @generated from field: string origin_chain = 2;
   */
  originChain: string;

  /**
   * Optional: Filter to a specific chain. If empty, returns denoms on all chains
   *
   * @generated from field: string on_chain_id = 3;
   */
  onChainId: string;
};

/**
 * Describes the message rpc.v1.GetTokenDenomsRequest.
 * Use `create(GetTokenDenomsRequestSchema)` to create a new message.
 */
export const GetTokenDenomsRequestSchema: GenMessage<GetTokenDenomsRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 15);

/**
 * @generated from message rpc.v1.GetTokenDenomsResponse
 */
export type GetTokenDenomsResponse = Message<"rpc.v1.GetTokenDenomsResponse"> & {
  /**
   * @generated from field: bool found = 1;
   */
  found: boolean;

  /**
   * @generated from field: string base_denom = 2;
   */
  baseDenom: string;

  /**
   * @generated from field: string origin_chain = 3;
   */
  originChain: string;

  /**
   * All chains where this token is available and what denom it has
   *
   * @generated from field: repeated rpc.v1.ChainDenom denoms = 4;
   */
  denoms: ChainDenom[];
};

/**
 * Describes the message rpc.v1.GetTokenDenomsResponse.
 * Use `create(GetTokenDenomsResponseSchema)` to create a new message.
 */
export const GetTokenDenomsResponseSchema: GenMessage<GetTokenDenomsResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 16);

/**
 * GetChainTokensRequest - Get all tokens on a chain
 *
 * @generated from message rpc.v1.GetChainTokensRequest
 */
export type GetChainTokensRequest = Message<"rpc.v1.GetChainTokensRequest"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;
};

/**
 * Describes the message rpc.v1.GetChainTokensRequest.
 * Use `create(GetChainTokensRequestSchema)` to create a new message.
 */
export const GetChainTokensRequestSchema: GenMessage<GetChainTokensRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 17);

/**
 * @generated from message rpc.v1.GetChainTokensResponse
 */
export type GetChainTokensResponse = Message<"rpc.v1.GetChainTokensResponse"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: string chain_name = 2;
   */
  chainName: string;

  /**
   * Native tokens on this chain
   *
   * @generated from field: repeated rpc.v1.TokenDetails native_tokens = 3;
   */
  nativeTokens: TokenDetails[];

  /**
   * IBC tokens received on this chain
   *
   * @generated from field: repeated rpc.v1.TokenDetails ibc_tokens = 4;
   */
  ibcTokens: TokenDetails[];
};

/**
 * Describes the message rpc.v1.GetChainTokensResponse.
 * Use `create(GetChainTokensResponseSchema)` to create a new message.
 */
export const GetChainTokensResponseSchema: GenMessage<GetChainTokensResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 18);

/**
 * TokenDetails - Full token information
 *
 * @generated from message rpc.v1.TokenDetails
 */
export type TokenDetails = Message<"rpc.v1.TokenDetails"> & {
  /**
   * Denom on this chain (native or IBC hash)
   *
   * @generated from field: string denom = 1;
   */
  denom: string;

  /**
   * Human-readable symbol (e.g., "ATONE", "OSMO")
   *
   * @generated from field: string symbol = 2;
   */
  symbol: string;

  /**
   * Base denom on origin chain
   *
   * @generated from field: string base_denom = 3;
   */
  baseDenom: string;

  /**
   * Chain where token is native
   *
   * @generated from field: string origin_chain = 4;
   */
  originChain: string;

  /**
   * Number of decimals
   *
   * @generated from field: int32 decimals = 5;
   */
  decimals: number;

  /**
   * True if native to this chain
   *
   * @generated from field: bool is_native = 6;
   */
  isNative: boolean;
};

/**
 * Describes the message rpc.v1.TokenDetails.
 * Use `create(TokenDetailsSchema)` to create a new message.
 */
export const TokenDetailsSchema: GenMessage<TokenDetails> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 19);

/**
 * @generated from message rpc.v1.PathfinderSupportedChainsResponse
 */
export type PathfinderSupportedChainsResponse = Message<"rpc.v1.PathfinderSupportedChainsResponse"> & {
  /**
   * @generated from field: repeated string chain_ids = 1;
   */
  chainIds: string[];
};

/**
 * Describes the message rpc.v1.PathfinderSupportedChainsResponse.
 * Use `create(PathfinderSupportedChainsResponseSchema)` to create a new message.
 */
export const PathfinderSupportedChainsResponseSchema: GenMessage<PathfinderSupportedChainsResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 20);

/**
 * @generated from message rpc.v1.ChainInfoRequest
 */
export type ChainInfoRequest = Message<"rpc.v1.ChainInfoRequest"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: bool sort_by_symbol = 2;
   */
  sortBySymbol: boolean;
};

/**
 * Describes the message rpc.v1.ChainInfoRequest.
 * Use `create(ChainInfoRequestSchema)` to create a new message.
 */
export const ChainInfoRequestSchema: GenMessage<ChainInfoRequest> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 21);

/**
 * @generated from message rpc.v1.ChainInfoResponse
 */
export type ChainInfoResponse = Message<"rpc.v1.ChainInfoResponse"> & {
  /**
   * @generated from field: rpc.v1.ChainInfo chain_info = 1;
   */
  chainInfo?: ChainInfo;
};

/**
 * Describes the message rpc.v1.ChainInfoResponse.
 * Use `create(ChainInfoResponseSchema)` to create a new message.
 */
export const ChainInfoResponseSchema: GenMessage<ChainInfoResponse> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 22);

/**
 * @generated from message rpc.v1.ChainInfo
 */
export type ChainInfo = Message<"rpc.v1.ChainInfo"> & {
  /**
   * @generated from field: string chain_id = 1;
   */
  chainId: string;

  /**
   * @generated from field: string chain_name = 2;
   */
  chainName: string;

  /**
   * @generated from field: bool has_pfm = 3;
   */
  hasPfm: boolean;

  /**
   * @generated from field: bool is_broker = 4;
   */
  isBroker: boolean;

  /**
   * @generated from field: repeated rpc.v1.BasicRoute routes = 5;
   */
  routes: BasicRoute[];
};

/**
 * Describes the message rpc.v1.ChainInfo.
 * Use `create(ChainInfoSchema)` to create a new message.
 */
export const ChainInfoSchema: GenMessage<ChainInfo> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 23);

/**
 * @generated from message rpc.v1.TokenInfo
 */
export type TokenInfo = Message<"rpc.v1.TokenInfo"> & {
  /**
   * @generated from field: string chain_denom = 1;
   */
  chainDenom: string;

  /**
   * @generated from field: string ibc_denom = 2;
   */
  ibcDenom: string;

  /**
   * @generated from field: string base_denom = 3;
   */
  baseDenom: string;

  /**
   * @generated from field: string origin_chain = 4;
   */
  originChain: string;

  /**
   * @generated from field: int32 decimals = 5;
   */
  decimals: number;

  /**
   * @generated from field: string symbol = 6;
   */
  symbol: string;
};

/**
 * Describes the message rpc.v1.TokenInfo.
 * Use `create(TokenInfoSchema)` to create a new message.
 */
export const TokenInfoSchema: GenMessage<TokenInfo> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 24);

/**
 * @generated from message rpc.v1.BasicRoute
 */
export type BasicRoute = Message<"rpc.v1.BasicRoute"> & {
  /**
   * @generated from field: string to_chain = 1;
   */
  toChain: string;

  /**
   * @generated from field: string to_chain_id = 2;
   */
  toChainId: string;

  /**
   * @generated from field: string connection_id = 3;
   */
  connectionId: string;

  /**
   * @generated from field: string channel_id = 4;
   */
  channelId: string;

  /**
   * @generated from field: string port_id = 5;
   */
  portId: string;

  /**
   * @generated from field: map<string, rpc.v1.TokenInfo> allowed_tokens = 6;
   */
  allowedTokens: { [key: string]: TokenInfo };
};

/**
 * Describes the message rpc.v1.BasicRoute.
 * Use `create(BasicRouteSchema)` to create a new message.
 */
export const BasicRouteSchema: GenMessage<BasicRoute> = /*@__PURE__*/
  messageDesc(file_pathfinder_route, 25);

/**
 * PathfinderService provides route discovery and validation for IBC transfers and swaps
 *
 * @generated from service rpc.v1.PathfinderService
 */
export const PathfinderService: GenService<{
  /**
   * FindPath finds and validates a route between two chains
   * Supports human-readable denoms (e.g., "uatone") or IBC denoms
   *
   * @generated from rpc rpc.v1.PathfinderService.FindPath
   */
  findPath: {
    methodKind: "unary";
    input: typeof FindPathRequestSchema;
    output: typeof FindPathResponseSchema;
  },
  /**
   * LookupDenom resolves denom information on a specific chain
   * Accepts human-readable base denoms or IBC denom hashes
   *
   * @generated from rpc rpc.v1.PathfinderService.LookupDenom
   */
  lookupDenom: {
    methodKind: "unary";
    input: typeof LookupDenomRequestSchema;
    output: typeof LookupDenomResponseSchema;
  },
  /**
   * GetTokenDenoms returns all IBC denoms for a token across supported chains
   * Use this to discover what denom a token has on different chains
   *
   * @generated from rpc rpc.v1.PathfinderService.GetTokenDenoms
   */
  getTokenDenoms: {
    methodKind: "unary";
    input: typeof GetTokenDenomsRequestSchema;
    output: typeof GetTokenDenomsResponseSchema;
  },
  /**
   * GetChainInfo returns information about a specific chain
   *
   * @generated from rpc rpc.v1.PathfinderService.GetChainInfo
   */
  getChainInfo: {
    methodKind: "unary";
    input: typeof ChainInfoRequestSchema;
    output: typeof ChainInfoResponseSchema;
  },
  /**
   * GetPathfinderSupportedChains returns a list of supported chains
   *
   * @generated from rpc rpc.v1.PathfinderService.GetPathfinderSupportedChains
   */
  getPathfinderSupportedChains: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof PathfinderSupportedChainsResponseSchema;
  },
  /**
   * GetChainTokens returns all tokens available on a specific chain
   * Includes both native tokens and IBC tokens with their denoms
   *
   * @generated from rpc rpc.v1.PathfinderService.GetChainTokens
   */
  getChainTokens: {
    methodKind: "unary";
    input: typeof GetChainTokensRequestSchema;
    output: typeof GetChainTokensResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_pathfinder_route, 0);

