syntax = "proto3";

package pathfinder.v1;

import "buf/validate/validate.proto";
import "google/protobuf/empty.proto";

option go_package = "github.com/Cogwheel-Validator/spectra-ibc-hub/pathfinder/rpc/v1";

// PathfinderService provides route discovery and validation for IBC transfers and swaps
service PathfinderService {
    // FindPath finds and validates a route between two chains
    // Supports human-readable denoms (e.g., "uatone") or IBC denoms
    rpc FindPath(FindPathRequest) returns (FindPathResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }
    
    // LookupDenom resolves denom information on a specific chain
    // Accepts human-readable base denoms or IBC denom hashes
    rpc LookupDenom(LookupDenomRequest) returns (LookupDenomResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // GetTokenDenoms returns all IBC denoms for a token across supported chains
    // Use this to discover what denom a token has on different chains
    rpc GetTokenDenoms(GetTokenDenomsRequest) returns (GetTokenDenomsResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // GetChainInfo returns information about a specific chain
    rpc GetChainInfo(ChainInfoRequest) returns (ChainInfoResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // ListSupportedChains returns a list of supported chains
    rpc ListSupportedChains(google.protobuf.Empty) returns (PathfinderSupportedChainsResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // GetChainTokens returns all tokens available on a specific chain
    // Includes both native tokens and IBC tokens with their denoms
    rpc GetChainTokens(GetChainTokensRequest) returns (GetChainTokensResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }
}

// FindPathRequest - Find a route between chains
// 
// For token_from_denom and token_to_denom, you can use:
// - Human-readable denom (e.g., "uatone", "uosmo", "ustars")
// - Full IBC denom (e.g., "ibc/ABC123...")
//
// The pathfinder will automatically resolve human-readable denoms.
// If token_to_denom is empty, the pathfinder assumes you want the same token
// on the destination chain (useful for bridging without swapping).
message FindPathRequest {
    // Source chain ID (e.g., "osmosis-1", "atomone-1")
    string chain_from = 1 [(buf.validate.field).required = true];
    
    // Token denom on source chain - can be human-readable (e.g., "uatone") 
    // or IBC denom (e.g., "ibc/...")
    string token_from_denom = 2 [
        (buf.validate.field).required = true, 
        (buf.validate.field).string.min_len = 1, 
        (buf.validate.field).string.max_len = 128];
    
    // Amount to transfer/swap (in base units)
    string amount_in = 3 [(buf.validate.field).required = true];
    
    // Destination chain ID
    string chain_to = 4 [(buf.validate.field).required = true];
    
    // Token denom you want to receive on destination chain
    // Can be human-readable (e.g., "uosmo") or IBC denom
    // If empty, assumes same token as token_from (bridging without swap)
    string token_to_denom = 5 [(buf.validate.field).string.max_len = 128];
    
    // Sender address on source chain
    string sender_address = 6 [
        (buf.validate.field).required = true, 
        (buf.validate.field).string.min_len = 38, 
        (buf.validate.field).string.max_len = 68];
    
    // Receiver address on destination chain
    string receiver_address = 7 [
        (buf.validate.field).required = true, 
        (buf.validate.field).string.min_len = 38, 
        (buf.validate.field).string.max_len = 68];
    
    // If true, return a smart route, if false, return a normal route
    bool smart_route = 8;

    // Slippage in basis points (e.g., 100 = 1%, 1000 = 10%)
    // Must be less than 10000
    uint32 slippage_bps = 9 [
        (buf.validate.field).required = false,
        (buf.validate.field).uint32.gte = 0,
        (buf.validate.field).uint32.lte = 10000
    ];
}

message FindPathResponse {
    bool success = 1;
    string error_message = 2;
    oneof route {
        DirectRoute direct = 3;
        IndirectRoute indirect = 4;
        BrokerSwapRoute broker_swap = 5;
    }
}

message DirectRoute {
    IBCLeg transfer = 1;
}

message IndirectRoute {
    repeated string path = 1;
    repeated IBCLeg legs = 2;
    bool supports_pfm = 3;
    string pfm_start_chain = 4;
    string pfm_memo = 5;
}

// BrokerSwapRoute represents a route involving a swap on a broker chain.
// Supports various scenarios:
// - Same-chain swap: inbound_leg absent, outbound_legs=[] (e.g., osmosis ATOM -> osmosis OSMO)
// - Swap from broker: inbound_leg absent (e.g., osmosis USDC -> juno JUNO)
// - Standard 3-chain: inbound_leg set, len(outbound_legs)=1
// - Multi-hop outbound: inbound_leg set, len(outbound_legs)>1 (e.g., cosmos ATOM -> swap -> noble -> juno)
message BrokerSwapRoute {
    // All chain IDs in order
    repeated string path = 1;
    // IBC transfer to reach broker (absent if starting from broker)
    repeated IBCLeg inbound_legs = 2;
    // The swap operation on the broker chain
    SwapQuote swap = 3;
    // IBC transfers after swap (empty if destination is broker)
    // Can be multiple for multi-hop forwarding via PFM
    repeated IBCLeg outbound_legs = 4;
    // Can use PFM for outbound legs
    bool outbound_supports_pfm = 5;
    // Execution data for building transactions
    BrokerExecutionData execution = 6;
}

// BrokerExecutionData contains ready-to-use transaction data
message BrokerExecutionData {
    // The IBC memo to use with MsgTransfer (contains wasm swap_and_action)
    optional string memo = 1;
    // The smart contract data to use with the swap and transfer
    optional WasmData smart_contract_data = 2;
    // Receiver address for MsgTransfer (the ibc-hooks contract)
    optional string ibc_receiver = 3;
    // Recovery address on broker chain (where funds go if swap/forward fails)
    string recover_address = 4;
    // Minimum output amount after slippage (1% default)
    string min_output_amount = 5;
    // True if using wasm ibc-hooks (vs simple PFM)
    bool uses_wasm = 6;
    // Human-readable description
    string description = 7;
}

message IBCLeg {
    string from_chain = 1;
    string to_chain = 2;
    string channel = 3;
    string port = 4;
    TokenMapping token = 5;
    string amount = 6;
}

message TokenMapping {
    // The denom as it appears on the current chain (native or IBC)
    string chain_denom = 1;
    // The base/native denom on the token's origin chain
    string base_denom = 2;
    // The chain ID where this token is native
    string origin_chain = 3;
    // True if this is the token's native chain
    bool is_native = 4;
}

// SwapQuote with broker-specific route data
message SwapQuote {
    string broker = 1;
    TokenMapping token_in = 2;
    TokenMapping token_out = 3;
    string amount_in = 4;
    string amount_out = 5;
    string price_impact = 6;
    string effective_fee = 7;
    
    // Broker-specific route data using oneof for type safety
    oneof route_data {
        OsmosisRouteData osmosis_route_data = 8;
        // Future brokers can be added here without breaking existing clients
    }
}

// Osmosis-specific route data (from SQS API)
message OsmosisRouteData {
    repeated OsmosisRoute routes = 1;
    string liquidity_cap = 2;
    bool liquidity_cap_overflow = 3;
}

message OsmosisRoute {
    repeated OsmosisPool pools = 1;
    bool has_cw_pool = 2;
    string out_amount = 3;
    string in_amount = 4;
}

message OsmosisPool {
    int32 id = 1;
    int32 type = 2;
    string spread_factor = 3;
    string token_out_denom = 4;
    string taker_fee = 5;
    string liquidity_cap = 6;
}

// LookupDenomRequest - Resolve token information
// Accepts either:
// - Human-readable denom (e.g., "uatone", "uosmo")
// - IBC denom (e.g., "ibc/ABC123...")
message LookupDenomRequest {
    string chain_id = 1 [(buf.validate.field).required = true];
    string denom = 2 [
        (buf.validate.field).required = true,
        (buf.validate.field).string.min_len = 1,
        (buf.validate.field).string.max_len = 128
    ];
}

message LookupDenomResponse {
    bool found = 1;
    // The denom as it appears on this chain
    string chain_denom = 2;
    // The base/native denom
    string base_denom = 3;
    // Where this token is native
    string origin_chain = 4;
    // True if this is the token's native chain
    bool is_native = 5;
    // IBC path if this is an IBC token (e.g., "transfer/channel-75")
    string ibc_path = 6;
    // Denoms on other chains where this token is available
    repeated ChainDenom available_on = 7;
}

// ChainDenom represents a token's denom on a specific chain
message ChainDenom {
    string chain_id = 1;
    string chain_name = 2;
    string denom = 3;
    bool is_native = 4;
}

// GetTokenDenomsRequest - Get all denoms for a token across chains
// Use this to discover what denom a token has on different chains
message GetTokenDenomsRequest {
    // The base denom (e.g., "uatone", "uosmo", "ustars")
    string base_denom = 1 [(buf.validate.field).required = true];
    // The chain where this token is native (e.g., "atomone-1", "osmosis-1")
    string origin_chain = 2 [(buf.validate.field).required = true];
    // Optional: Filter to a specific chain. If empty, returns denoms on all chains
    string on_chain_id = 3;
}

message GetTokenDenomsResponse {
    bool found = 1;
    string base_denom = 2;
    string origin_chain = 3;
    // All chains where this token is available and what denom it has
    repeated ChainDenom denoms = 4;
}

// GetChainTokensRequest - Get all tokens on a chain
message GetChainTokensRequest {
    string chain_id = 1 [(buf.validate.field).required = true];
}

message GetChainTokensResponse {
    string chain_id = 1;
    string chain_name = 2;
    // Native tokens on this chain
    repeated TokenDetails native_tokens = 3;
    // IBC tokens received on this chain
    repeated TokenDetails ibc_tokens = 4;
}

// TokenDetails - Full token information
message TokenDetails {
    // Denom on this chain (native or IBC hash)
    string denom = 1;
    // Human-readable symbol (e.g., "ATONE", "OSMO")
    string symbol = 2;
    // Base denom on origin chain
    string base_denom = 3;
    // Chain where token is native
    string origin_chain = 4;
    // Number of decimals
    int32 decimals = 5;
    // True if native to this chain
    bool is_native = 6;
}

message PathfinderSupportedChainsResponse {
    repeated string chain_ids = 1 [(buf.validate.field).required = true];
}

message ChainInfoRequest {
    // The chain id of the chain to get information for
    string chain_id = 1 [(buf.validate.field).required = true];
    // Whether to show the symbols of the tokens on the chain, default is false
    bool show_symbols = 2;
}

message ChainInfoResponse {
    ChainInfo chain_info = 1;
}

message ChainInfo {
    string chain_id = 1;
    string chain_name = 2;
    bool has_pfm = 3;
    bool is_broker = 4;
    repeated BasicRoute routes = 5;
}

message TokenInfo {
    string chain_denom = 1;
    string ibc_denom = 2;
    string base_denom = 3;
    string origin_chain = 4;
    int32 decimals = 5;
    string symbol = 6;
}

message BasicRoute {
    string to_chain = 1;
    string to_chain_id = 2;
    string connection_id = 3;
    string channel_id = 4;
    string port_id = 5;
    map<string, TokenInfo> allowed_tokens = 6;
}

message WasmData {

    string contract = 1;
    WasmMsg msg = 2;
}

message WasmMsg {
    SwapAndAction swap_and_action = 1;
}

message SwapAndAction {
    // SwapAndAction is the entry point contract message structure
    UserSwap user_swap = 1;
    MinAsset min_asset = 2;
    int64 timeout_timestamp = 3;
    PostSwapAction post_swap_action = 4;
    repeated string affiliates = 5;
}
    
message SwapExactAssetIn {
    string swap_venue_name = 1;
    repeated SwapOperation operations = 2;
}

message SwapOperation {
    string pool = 1;
    string denom_in = 2;
    string denom_out = 3;
    // Interface is used by some DEXs (like Injective), optional
    optional string interface = 4;
}

message MinAsset {
    Asset native = 1;
}

message Asset {
    string amount = 1;
    string denom = 2;
}

message PostSwapAction {
    oneof action {
        IBCTransfer ibc_transfer = 1;
        Transfer transfer = 2;
    }
}

message IBCTransfer {
    IBCInfo ibc_info = 1;
}

message Transfer {
    string to_address = 1;
}

message IBCInfo {
    string memo = 1;
    string receiver = 2;
    string recover_address = 3;
    string source_channel = 4;
}

message UserSwap {
    SwapExactAssetIn swap_exact_asset_in = 1;
}   