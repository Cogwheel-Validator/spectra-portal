syntax = "proto3";

package pathfinder.v1;

import "buf/validate/validate.proto";
import "google/protobuf/empty.proto";

option go_package = "github.com/Cogwheel-Validator/spectra-ibc-hub/pathfinder/rpc/v1";

// PathfinderService provides route discovery and validation for IBC transfers and swaps
service PathfinderService {
    // FindPath finds and validates a route between two chains
    // Supports human-readable denoms (e.g., "uatone") or IBC denoms
    rpc FindPath(FindPathRequest) returns (FindPathResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }
    
    // LookupDenom resolves denom information on a specific chain
    // Accepts human-readable base denoms or IBC denom hashes
    rpc LookupDenom(LookupDenomRequest) returns (LookupDenomResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // GetTokenDenoms returns all IBC denoms for a token across supported chains
    // Use this to discover what denom a token has on different chains
    rpc GetTokenDenoms(GetTokenDenomsRequest) returns (GetTokenDenomsResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // GetChainInfo returns information about a specific chain
    rpc GetChainInfo(ChainInfoRequest) returns (ChainInfoResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // ListSupportedChains returns a list of supported chains
    rpc ListSupportedChains(google.protobuf.Empty) returns (PathfinderSupportedChainsResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // GetChainTokens returns all tokens available on a specific chain
    // Includes both native tokens and IBC tokens with their denoms
    rpc GetChainTokens(GetChainTokensRequest) returns (GetChainTokensResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }
}

// FindPathRequest - Find a route between chains
// 
// For token_from_denom and token_to_denom, you can use:
// - Human-readable denom (e.g., "uatone", "uosmo", "ustars")
// - Full IBC denom (e.g., "ibc/ABC123...")
//
// The pathfinder will automatically resolve human-readable denoms.
// If token_to_denom is empty, the pathfinder assumes you want the same token
// on the destination chain (useful for bridging without swapping).
message FindPathRequest {
    // Source chain ID (e.g., "osmosis-1", "atomone-1")
    string chain_from = 1 [(buf.validate.field).required = true];
    
    // Token denom on source chain - can be human-readable (e.g., "uatone") 
    // or IBC denom (e.g., "ibc/...")
    string token_from_denom = 2 [
        (buf.validate.field).required = true, 
        (buf.validate.field).string.min_len = 1, 
        (buf.validate.field).string.max_len = 128];
    
    // Amount to transfer/swap (in base units)
    string amount_in = 3 [(buf.validate.field).required = true];
    
    // Destination chain ID
    string chain_to = 4 [(buf.validate.field).required = true];
    
    // Token denom you want to receive on destination chain
    // Can be human-readable (e.g., "uosmo") or IBC denom
    // If empty, assumes same token as token_from (bridging without swap)
    string token_to_denom = 5 [(buf.validate.field).string.max_len = 128];
    
    // Sender address on source chain
    string sender_address = 6 [
        (buf.validate.field).required = true, 
        (buf.validate.field).string.min_len = 38, 
        (buf.validate.field).string.max_len = 68];
    
    // Receiver address on destination chain
    string receiver_address = 7 [
        (buf.validate.field).required = true, 
        (buf.validate.field).string.min_len = 38, 
        (buf.validate.field).string.max_len = 68];
    
    // If true, return a smart route, if false, return a normal route
    bool smart_route = 8;

    // Slippage in basis points (e.g., 100 = 1%, 1000 = 10%)
    // Must be less than 10000
    uint32 slippage_bps = 9 [
        (buf.validate.field).required = false,
        (buf.validate.field).uint32.gte = 0,
        (buf.validate.field).uint32.lte = 10000
    ];
}

message FindPathResponse {
    bool success = 1 [json_name = "success"];
    string error_message = 2 [json_name = "error_message"];
    oneof route {
        DirectRoute direct = 3 [json_name = "direct"];
        IndirectRoute indirect = 4 [json_name = "indirect"];
        BrokerSwapRoute broker_swap = 5 [json_name = "broker_swap"];
    }
}

message DirectRoute {
    IBCLeg transfer = 1 [json_name = "transfer"];
}

message IndirectRoute {
    repeated string path = 1 [json_name = "path"];
    repeated IBCLeg legs = 2 [json_name = "legs"];
    bool supports_pfm = 3 [json_name = "supports_pfm"];
    string pfm_start_chain = 4 [json_name = "pfm_start_chain"];
    string pfm_memo = 5 [json_name = "pfm_memo"];
}

// BrokerSwapRoute represents a route involving a swap on a broker chain.
// Supports various scenarios:
// - Same-chain swap: inbound_leg absent, outbound_legs=[] (e.g., osmosis ATOM -> osmosis OSMO)
// - Swap from broker: inbound_leg absent (e.g., osmosis USDC -> juno JUNO)
// - Standard 3-chain: inbound_leg set, len(outbound_legs)=1
// - Multi-hop outbound: inbound_leg set, len(outbound_legs)>1 (e.g., cosmos ATOM -> swap -> noble -> juno)
message BrokerSwapRoute {
    // All chain IDs in order
    repeated string path = 1 [json_name = "path"];
    // IBC transfer to reach broker (absent if starting from broker)
    repeated IBCLeg inbound_legs = 2 [json_name = "inbound_legs"];
    // The swap operation on the broker chain
    SwapQuote swap = 3 [json_name = "swap"];
    // IBC transfers after swap (empty if destination is broker)
    // Can be multiple for multi-hop forwarding via PFM
    repeated IBCLeg outbound_legs = 4 [json_name = "outbound_legs"];
    // Can use PFM for outbound legs
    bool outbound_supports_pfm = 5 [json_name = "outbound_supports_pfm"];
    // Execution data for building transactions
    BrokerExecutionData execution = 6 [json_name = "execution"];
}

// BrokerExecutionData contains ready-to-use transaction data
message BrokerExecutionData {
    // The IBC memo to use with MsgTransfer (contains wasm swap_and_action)
    optional string memo = 1 [json_name = "memo"];
    // The smart contract data to use with the swap and transfer
    optional WasmData smart_contract_data = 2 [json_name = "smart_contract_data"];
    // Receiver address for MsgTransfer (the ibc-hooks contract)
    optional string ibc_receiver = 3 [json_name = "ibc_receiver"];
    // Recovery address on broker chain (where funds go if swap/forward fails)
    string recover_address = 4 [json_name = "recover_address"];
    // Minimum output amount after slippage (1% default)
    string min_output_amount = 5 [json_name = "min_output_amount"];
    // True if using wasm ibc-hooks (vs simple PFM)
    bool uses_wasm = 6 [json_name = "uses_wasm"];
    // Human-readable description
    string description = 7 [json_name = "description"];
}

message IBCLeg {
    string from_chain = 1 [json_name = "from_chain"];
    string to_chain = 2 [json_name = "to_chain"];
    string channel = 3 [json_name = "channel"];
    string port = 4 [json_name = "port"];
    TokenMapping token = 5 [json_name = "token"];
    string amount = 6 [json_name = "amount"];
}

message TokenMapping {
    // The denom as it appears on the current chain (native or IBC)
    string chain_denom = 1 [json_name = "chain_denom"];
    // The base/native denom on the token's origin chain
    string base_denom = 2 [json_name = "base_denom"];
    // The chain ID where this token is native
    string origin_chain = 3 [json_name = "origin_chain"];
    // True if this is the token's native chain
    bool is_native = 4 [json_name = "is_native"];
}

// SwapQuote with broker-specific route data
message SwapQuote {
    string broker = 1 [json_name = "broker"];
    TokenMapping token_in = 2 [json_name = "token_in"];
    TokenMapping token_out = 3 [json_name = "token_out"];
    string amount_in = 4 [json_name = "amount_in"];
    string amount_out = 5 [json_name = "amount_out"];
    string price_impact = 6 [json_name = "price_impact"];
    string effective_fee = 7 [json_name = "effective_fee"];
    
    // Broker-specific route data using oneof for type safety
    oneof route_data {
        OsmosisRouteData osmosis_route_data = 8 [json_name = "osmosis_route_data"];
        // Future brokers can be added here without breaking existing clients
    }
}

// Osmosis-specific route data (from SQS API)
message OsmosisRouteData {
    repeated OsmosisRoute routes = 1 [json_name = "routes"];
    string liquidity_cap = 2 [json_name = "liquidity_cap"];
    bool liquidity_cap_overflow = 3 [json_name = "liquidity_cap_overflow"];
}

message OsmosisRoute {
    repeated OsmosisPool pools = 1 [json_name = "pools"];
    bool has_cw_pool = 2 [json_name = "has_cw_pool"];
    string out_amount = 3 [json_name = "out_amount"];
    string in_amount = 4 [json_name = "in_amount"];
}

message OsmosisPool {
    int32 id = 1 [json_name = "id"];
    int32 type = 2 [json_name = "type"];
    string spread_factor = 3 [json_name = "spread_factor"];
    string token_out_denom = 4 [json_name = "token_out_denom"];
    string taker_fee = 5 [json_name = "taker_fee"];
    string liquidity_cap = 6 [json_name = "liquidity_cap"];
}

// LookupDenomRequest - Resolve token information
// Accepts either:
// - Human-readable denom (e.g., "uatone", "uosmo")
// - IBC denom (e.g., "ibc/ABC123...")
message LookupDenomRequest {
    string chain_id = 1 [(buf.validate.field).required = true];
    string denom = 2 [
        (buf.validate.field).required = true,
        (buf.validate.field).string.min_len = 1,
        (buf.validate.field).string.max_len = 128
    ];
}

message LookupDenomResponse {
    bool found = 1 [json_name = "found"];
    // The denom as it appears on this chain
    string chain_denom = 2 [json_name = "chain_denom"];
    // The base/native denom
    string base_denom = 3 [json_name = "base_denom"];
    // Where this token is native
    string origin_chain = 4 [json_name = "origin_chain"];
    // True if this is the token's native chain
    bool is_native = 5 [json_name = "is_native"];
    // IBC path if this is an IBC token (e.g., "transfer/channel-75")
    string ibc_path = 6 [json_name = "ibc_path"];
    // Denoms on other chains where this token is available
    repeated ChainDenom available_on = 7 [json_name = "available_on"];
}

// ChainDenom represents a token's denom on a specific chain
message ChainDenom {
    string chain_id = 1 [json_name = "chain_id"];
    string chain_name = 2 [json_name = "chain_name"];
    string denom = 3 [json_name = "denom"];
    bool is_native = 4 [json_name = "is_native"];
}

// GetTokenDenomsRequest - Get all denoms for a token across chains
// Use this to discover what denom a token has on different chains
message GetTokenDenomsRequest {
    // The base denom (e.g., "uatone", "uosmo", "ustars")
    string base_denom = 1 [(buf.validate.field).required = true];
    // The chain where this token is native (e.g., "atomone-1", "osmosis-1")
    string origin_chain = 2 [(buf.validate.field).required = true];
    // Optional: Filter to a specific chain. If empty, returns denoms on all chains
    string on_chain_id = 3;
}

message GetTokenDenomsResponse {
    bool found = 1 [json_name = "found"];
    string base_denom = 2 [json_name = "base_denom"];
    string origin_chain = 3 [json_name = "origin_chain"];
    // All chains where this token is available and what denom it has
    repeated ChainDenom denoms = 4 [json_name = "denoms"];
}

// GetChainTokensRequest - Get all tokens on a chain
message GetChainTokensRequest {
    string chain_id = 1 [(buf.validate.field).required = true];
}

message GetChainTokensResponse {
    string chain_id = 1 [json_name = "chain_id"];
    string chain_name = 2 [json_name = "chain_name"];
    // Native tokens on this chain
    repeated TokenDetails native_tokens = 3 [json_name = "native_tokens"];
    // IBC tokens received on this chain
    repeated TokenDetails ibc_tokens = 4 [json_name = "ibc_tokens"];
}

// TokenDetails - Full token information
message TokenDetails {
    // Denom on this chain (native or IBC hash)
    string denom = 1 [json_name = "denom"];
    // Human-readable symbol (e.g., "ATONE", "OSMO")
    string symbol = 2 [json_name = "symbol"];
    // Base denom on origin chain
    string base_denom = 3 [json_name = "base_denom"];
    // Chain where token is native
    string origin_chain = 4 [json_name = "origin_chain"];
    // Number of decimals
    int32 decimals = 5 [json_name = "decimals"];
    // True if native to this chain
    bool is_native = 6 [json_name = "is_native"];
}

message PathfinderSupportedChainsResponse {
    repeated string chain_ids = 1 [(buf.validate.field).required = true, json_name = "chain_ids"];
}

message ChainInfoRequest {
    // The chain id of the chain to get information for
    string chain_id = 1 [(buf.validate.field).required = true];
    // Whether to show the symbols of the tokens on the chain, default is false
    bool show_symbols = 2;
}

message ChainInfoResponse {
    ChainInfo chain_info = 1 [json_name = "chain_info"];
}

message ChainInfo {
    string chain_id = 1 [json_name = "chain_id"];
    string chain_name = 2 [json_name = "chain_name"];
    bool has_pfm = 3 [json_name = "has_pfm"];
    bool is_broker = 4 [json_name = "is_broker"];
    repeated BasicRoute routes = 5 [json_name = "routes"];
}

message TokenInfo {
    string chain_denom = 1 [json_name = "chain_denom"];
    string ibc_denom = 2 [json_name = "ibc_denom"];
    string base_denom = 3 [json_name = "base_denom"];
    string origin_chain = 4 [json_name = "origin_chain"];
    int32 decimals = 5 [json_name = "decimals"];
    string symbol = 6 [json_name = "symbol"];
}

message BasicRoute {
    string to_chain = 1 [json_name = "to_chain"];
    string to_chain_id = 2 [json_name = "to_chain_id"];
    string connection_id = 3 [json_name = "connection_id"];
    string channel_id = 4 [json_name = "channel_id"];
    string port_id = 5 [json_name = "port_id"];
    map<string, TokenInfo> allowed_tokens = 6 [json_name = "allowed_tokens"];
}

message WasmData {

    string contract = 1 [json_name = "contract"];
    WasmMsg msg = 2 [json_name = "msg"];
}

message WasmMsg {
    SwapAndAction swap_and_action = 1 [json_name = "swap_and_action"];
}

message SwapAndAction {
    // SwapAndAction is the entry point contract message structure
    UserSwap user_swap = 1 [json_name = "user_swap"];
    MinAsset min_asset = 2 [json_name = "min_asset"];
    int64 timeout_timestamp = 3 [json_name = "timeout_timestamp"];
    PostSwapAction post_swap_action = 4 [json_name = "post_swap_action"];
    repeated string affiliates = 5 [json_name = "affiliates"];
}
    
message SwapExactAssetIn {
    string swap_venue_name = 1 [json_name = "swap_venue_name"];
    repeated SwapOperation operations = 2 [json_name = "operations"];
}

message SwapOperation {
    string pool = 1 [json_name = "pool"];
    string denom_in = 2 [json_name = "denom_in"];
    string denom_out = 3 [json_name = "denom_out"];
    // Interface is used by some DEXs (like Injective), optional
    optional string interface = 4 [json_name = "interface"];
}

message MinAsset {
    Asset native = 1 [json_name = "native"];
}

message Asset {
    string amount = 1 [json_name = "amount"];
    string denom = 2 [json_name = "denom"];
}

message PostSwapAction {
    oneof action {
        IBCTransfer ibc_transfer = 1 [json_name = "ibc_transfer"];
        Transfer transfer = 2 [json_name = "transfer"];
    }
}

message IBCTransfer {
    IBCInfo ibc_info = 1 [json_name = "ibc_info"];
}

message Transfer {
    string to_address = 1 [json_name = "to_address"];
}

message IBCInfo {
    string memo = 1 [json_name = "memo"];
    string receiver = 2 [json_name = "receiver"];
    string recover_address = 3 [json_name = "recover_address"];
    string source_channel = 4 [json_name = "source_channel"];
}

message UserSwap {
    SwapExactAssetIn swap_exact_asset_in = 1 [json_name = "swap_exact_asset_in"];
}   